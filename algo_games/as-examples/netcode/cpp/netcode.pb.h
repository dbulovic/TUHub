// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: netcode.proto

#ifndef PROTOBUF_INCLUDED_netcode_2eproto
#define PROTOBUF_INCLUDED_netcode_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "nim.pb.h"
#include "dots-and-boxes.pb.h"
#include "dominect.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_netcode_2eproto 

namespace protobuf_netcode_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[19];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_netcode_2eproto
namespace netcode {
class AuthPacket;
class AuthPacketDefaultTypeInternal;
extern AuthPacketDefaultTypeInternal _AuthPacket_default_instance_;
class DirectChallenge;
class DirectChallengeDefaultTypeInternal;
extern DirectChallengeDefaultTypeInternal _DirectChallenge_default_instance_;
class GameStateResponse;
class GameStateResponseDefaultTypeInternal;
extern GameStateResponseDefaultTypeInternal _GameStateResponse_default_instance_;
class GetTimeoutResponse;
class GetTimeoutResponseDefaultTypeInternal;
extern GetTimeoutResponseDefaultTypeInternal _GetTimeoutResponse_default_instance_;
class GetUserTokenResponse;
class GetUserTokenResponseDefaultTypeInternal;
extern GetUserTokenResponseDefaultTypeInternal _GetUserTokenResponse_default_instance_;
class GroupRegistrationRequest;
class GroupRegistrationRequestDefaultTypeInternal;
extern GroupRegistrationRequestDefaultTypeInternal _GroupRegistrationRequest_default_instance_;
class GroupRegistrationResponse;
class GroupRegistrationResponseDefaultTypeInternal;
extern GroupRegistrationResponseDefaultTypeInternal _GroupRegistrationResponse_default_instance_;
class MatchIDPacket;
class MatchIDPacketDefaultTypeInternal;
extern MatchIDPacketDefaultTypeInternal _MatchIDPacket_default_instance_;
class MatchRequest;
class MatchRequestDefaultTypeInternal;
extern MatchRequestDefaultTypeInternal _MatchRequest_default_instance_;
class MatchResponse;
class MatchResponseDefaultTypeInternal;
extern MatchResponseDefaultTypeInternal _MatchResponse_default_instance_;
class MatchmakingParameter;
class MatchmakingParameterDefaultTypeInternal;
extern MatchmakingParameterDefaultTypeInternal _MatchmakingParameter_default_instance_;
class Nothing;
class NothingDefaultTypeInternal;
extern NothingDefaultTypeInternal _Nothing_default_instance_;
class OpponentInfoResponse;
class OpponentInfoResponseDefaultTypeInternal;
extern OpponentInfoResponseDefaultTypeInternal _OpponentInfoResponse_default_instance_;
class SetPseudonymRequest;
class SetPseudonymRequestDefaultTypeInternal;
extern SetPseudonymRequestDefaultTypeInternal _SetPseudonymRequest_default_instance_;
class SetPseudonymResponse;
class SetPseudonymResponseDefaultTypeInternal;
extern SetPseudonymResponseDefaultTypeInternal _SetPseudonymResponse_default_instance_;
class TurnRequest;
class TurnRequestDefaultTypeInternal;
extern TurnRequestDefaultTypeInternal _TurnRequest_default_instance_;
class TurnResponse;
class TurnResponseDefaultTypeInternal;
extern TurnResponseDefaultTypeInternal _TurnResponse_default_instance_;
class UserRegistrationRequest;
class UserRegistrationRequestDefaultTypeInternal;
extern UserRegistrationRequestDefaultTypeInternal _UserRegistrationRequest_default_instance_;
class UserRegistrationResponse;
class UserRegistrationResponseDefaultTypeInternal;
extern UserRegistrationResponseDefaultTypeInternal _UserRegistrationResponse_default_instance_;
}  // namespace netcode
namespace google {
namespace protobuf {
template<> ::netcode::AuthPacket* Arena::CreateMaybeMessage<::netcode::AuthPacket>(Arena*);
template<> ::netcode::DirectChallenge* Arena::CreateMaybeMessage<::netcode::DirectChallenge>(Arena*);
template<> ::netcode::GameStateResponse* Arena::CreateMaybeMessage<::netcode::GameStateResponse>(Arena*);
template<> ::netcode::GetTimeoutResponse* Arena::CreateMaybeMessage<::netcode::GetTimeoutResponse>(Arena*);
template<> ::netcode::GetUserTokenResponse* Arena::CreateMaybeMessage<::netcode::GetUserTokenResponse>(Arena*);
template<> ::netcode::GroupRegistrationRequest* Arena::CreateMaybeMessage<::netcode::GroupRegistrationRequest>(Arena*);
template<> ::netcode::GroupRegistrationResponse* Arena::CreateMaybeMessage<::netcode::GroupRegistrationResponse>(Arena*);
template<> ::netcode::MatchIDPacket* Arena::CreateMaybeMessage<::netcode::MatchIDPacket>(Arena*);
template<> ::netcode::MatchRequest* Arena::CreateMaybeMessage<::netcode::MatchRequest>(Arena*);
template<> ::netcode::MatchResponse* Arena::CreateMaybeMessage<::netcode::MatchResponse>(Arena*);
template<> ::netcode::MatchmakingParameter* Arena::CreateMaybeMessage<::netcode::MatchmakingParameter>(Arena*);
template<> ::netcode::Nothing* Arena::CreateMaybeMessage<::netcode::Nothing>(Arena*);
template<> ::netcode::OpponentInfoResponse* Arena::CreateMaybeMessage<::netcode::OpponentInfoResponse>(Arena*);
template<> ::netcode::SetPseudonymRequest* Arena::CreateMaybeMessage<::netcode::SetPseudonymRequest>(Arena*);
template<> ::netcode::SetPseudonymResponse* Arena::CreateMaybeMessage<::netcode::SetPseudonymResponse>(Arena*);
template<> ::netcode::TurnRequest* Arena::CreateMaybeMessage<::netcode::TurnRequest>(Arena*);
template<> ::netcode::TurnResponse* Arena::CreateMaybeMessage<::netcode::TurnResponse>(Arena*);
template<> ::netcode::UserRegistrationRequest* Arena::CreateMaybeMessage<::netcode::UserRegistrationRequest>(Arena*);
template<> ::netcode::UserRegistrationResponse* Arena::CreateMaybeMessage<::netcode::UserRegistrationResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace netcode {

enum SetPseudonymResponse_ErrorCode {
  SetPseudonymResponse_ErrorCode_UNDEFINED_ERROR = 0,
  SetPseudonymResponse_ErrorCode_OK = 1,
  SetPseudonymResponse_ErrorCode_REQUEST_REJECTED = 2,
  SetPseudonymResponse_ErrorCode_ALREADY_USED = 3,
  SetPseudonymResponse_ErrorCode_TOO_LONG = 4,
  SetPseudonymResponse_ErrorCode_EMPTY_FIELDS = 5,
  SetPseudonymResponse_ErrorCode_SetPseudonymResponse_ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SetPseudonymResponse_ErrorCode_SetPseudonymResponse_ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SetPseudonymResponse_ErrorCode_IsValid(int value);
const SetPseudonymResponse_ErrorCode SetPseudonymResponse_ErrorCode_ErrorCode_MIN = SetPseudonymResponse_ErrorCode_UNDEFINED_ERROR;
const SetPseudonymResponse_ErrorCode SetPseudonymResponse_ErrorCode_ErrorCode_MAX = SetPseudonymResponse_ErrorCode_EMPTY_FIELDS;
const int SetPseudonymResponse_ErrorCode_ErrorCode_ARRAYSIZE = SetPseudonymResponse_ErrorCode_ErrorCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* SetPseudonymResponse_ErrorCode_descriptor();
inline const ::std::string& SetPseudonymResponse_ErrorCode_Name(SetPseudonymResponse_ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    SetPseudonymResponse_ErrorCode_descriptor(), value);
}
inline bool SetPseudonymResponse_ErrorCode_Parse(
    const ::std::string& name, SetPseudonymResponse_ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SetPseudonymResponse_ErrorCode>(
    SetPseudonymResponse_ErrorCode_descriptor(), name, value);
}
enum UserRegistrationResponse_ErrorCode {
  UserRegistrationResponse_ErrorCode_UNDEFINED_ERROR = 0,
  UserRegistrationResponse_ErrorCode_OK = 1,
  UserRegistrationResponse_ErrorCode_INVALID_PARAMETER = 2,
  UserRegistrationResponse_ErrorCode_EMPTY_FIELDS = 3,
  UserRegistrationResponse_ErrorCode_NOT_ALLOWED = 4,
  UserRegistrationResponse_ErrorCode_UserRegistrationResponse_ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  UserRegistrationResponse_ErrorCode_UserRegistrationResponse_ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool UserRegistrationResponse_ErrorCode_IsValid(int value);
const UserRegistrationResponse_ErrorCode UserRegistrationResponse_ErrorCode_ErrorCode_MIN = UserRegistrationResponse_ErrorCode_UNDEFINED_ERROR;
const UserRegistrationResponse_ErrorCode UserRegistrationResponse_ErrorCode_ErrorCode_MAX = UserRegistrationResponse_ErrorCode_NOT_ALLOWED;
const int UserRegistrationResponse_ErrorCode_ErrorCode_ARRAYSIZE = UserRegistrationResponse_ErrorCode_ErrorCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserRegistrationResponse_ErrorCode_descriptor();
inline const ::std::string& UserRegistrationResponse_ErrorCode_Name(UserRegistrationResponse_ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserRegistrationResponse_ErrorCode_descriptor(), value);
}
inline bool UserRegistrationResponse_ErrorCode_Parse(
    const ::std::string& name, UserRegistrationResponse_ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserRegistrationResponse_ErrorCode>(
    UserRegistrationResponse_ErrorCode_descriptor(), name, value);
}
enum GroupRegistrationResponse_ErrorCode {
  GroupRegistrationResponse_ErrorCode_UNDEFINED_ERROR = 0,
  GroupRegistrationResponse_ErrorCode_OK = 1,
  GroupRegistrationResponse_ErrorCode_UNKNOWN_USER = 2,
  GroupRegistrationResponse_ErrorCode_TOO_MANY_GROUP_MEMBERS = 3,
  GroupRegistrationResponse_ErrorCode_USER_ALREADY_REGISTERED = 4,
  GroupRegistrationResponse_ErrorCode_AUTH_FAILED = 5,
  GroupRegistrationResponse_ErrorCode_GroupRegistrationResponse_ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  GroupRegistrationResponse_ErrorCode_GroupRegistrationResponse_ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool GroupRegistrationResponse_ErrorCode_IsValid(int value);
const GroupRegistrationResponse_ErrorCode GroupRegistrationResponse_ErrorCode_ErrorCode_MIN = GroupRegistrationResponse_ErrorCode_UNDEFINED_ERROR;
const GroupRegistrationResponse_ErrorCode GroupRegistrationResponse_ErrorCode_ErrorCode_MAX = GroupRegistrationResponse_ErrorCode_AUTH_FAILED;
const int GroupRegistrationResponse_ErrorCode_ErrorCode_ARRAYSIZE = GroupRegistrationResponse_ErrorCode_ErrorCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupRegistrationResponse_ErrorCode_descriptor();
inline const ::std::string& GroupRegistrationResponse_ErrorCode_Name(GroupRegistrationResponse_ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupRegistrationResponse_ErrorCode_descriptor(), value);
}
inline bool GroupRegistrationResponse_ErrorCode_Parse(
    const ::std::string& name, GroupRegistrationResponse_ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupRegistrationResponse_ErrorCode>(
    GroupRegistrationResponse_ErrorCode_descriptor(), name, value);
}
enum TurnStatus {
  OK = 0,
  INVALID_TURN = 1,
  NOT_YOUR_TURN = 2,
  MATCH_OVER = 3,
  TurnStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TurnStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TurnStatus_IsValid(int value);
const TurnStatus TurnStatus_MIN = OK;
const TurnStatus TurnStatus_MAX = MATCH_OVER;
const int TurnStatus_ARRAYSIZE = TurnStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* TurnStatus_descriptor();
inline const ::std::string& TurnStatus_Name(TurnStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    TurnStatus_descriptor(), value);
}
inline bool TurnStatus_Parse(
    const ::std::string& name, TurnStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TurnStatus>(
    TurnStatus_descriptor(), name, value);
}
enum GameStatus {
  YOUR_TURN = 0,
  OPPONENTS_TURN = 1,
  MATCH_WON = 3,
  MATCH_LOST = 4,
  DRAW = 5,
  MATCH_NOT_STARTED = 6,
  MATCH_ABORTED = 7,
  GameStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  GameStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool GameStatus_IsValid(int value);
const GameStatus GameStatus_MIN = YOUR_TURN;
const GameStatus GameStatus_MAX = MATCH_ABORTED;
const int GameStatus_ARRAYSIZE = GameStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameStatus_descriptor();
inline const ::std::string& GameStatus_Name(GameStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameStatus_descriptor(), value);
}
inline bool GameStatus_Parse(
    const ::std::string& name, GameStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameStatus>(
    GameStatus_descriptor(), name, value);
}
// ===================================================================

class AuthPacket : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netcode.AuthPacket) */ {
 public:
  AuthPacket();
  virtual ~AuthPacket();

  AuthPacket(const AuthPacket& from);

  inline AuthPacket& operator=(const AuthPacket& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AuthPacket(AuthPacket&& from) noexcept
    : AuthPacket() {
    *this = ::std::move(from);
  }

  inline AuthPacket& operator=(AuthPacket&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthPacket& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AuthPacket* internal_default_instance() {
    return reinterpret_cast<const AuthPacket*>(
               &_AuthPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(AuthPacket* other);
  friend void swap(AuthPacket& a, AuthPacket& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AuthPacket* New() const final {
    return CreateMaybeMessage<AuthPacket>(NULL);
  }

  AuthPacket* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AuthPacket>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AuthPacket& from);
  void MergeFrom(const AuthPacket& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthPacket* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string matr_number = 1;
  void clear_matr_number();
  static const int kMatrNumberFieldNumber = 1;
  const ::std::string& matr_number() const;
  void set_matr_number(const ::std::string& value);
  #if LANG_CXX11
  void set_matr_number(::std::string&& value);
  #endif
  void set_matr_number(const char* value);
  void set_matr_number(const char* value, size_t size);
  ::std::string* mutable_matr_number();
  ::std::string* release_matr_number();
  void set_allocated_matr_number(::std::string* matr_number);

  // string secret = 2;
  void clear_secret();
  static const int kSecretFieldNumber = 2;
  const ::std::string& secret() const;
  void set_secret(const ::std::string& value);
  #if LANG_CXX11
  void set_secret(::std::string&& value);
  #endif
  void set_secret(const char* value);
  void set_secret(const char* value, size_t size);
  ::std::string* mutable_secret();
  ::std::string* release_secret();
  void set_allocated_secret(::std::string* secret);

  // @@protoc_insertion_point(class_scope:netcode.AuthPacket)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr matr_number_;
  ::google::protobuf::internal::ArenaStringPtr secret_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_netcode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MatchIDPacket : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netcode.MatchIDPacket) */ {
 public:
  MatchIDPacket();
  virtual ~MatchIDPacket();

  MatchIDPacket(const MatchIDPacket& from);

  inline MatchIDPacket& operator=(const MatchIDPacket& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MatchIDPacket(MatchIDPacket&& from) noexcept
    : MatchIDPacket() {
    *this = ::std::move(from);
  }

  inline MatchIDPacket& operator=(MatchIDPacket&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchIDPacket& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MatchIDPacket* internal_default_instance() {
    return reinterpret_cast<const MatchIDPacket*>(
               &_MatchIDPacket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(MatchIDPacket* other);
  friend void swap(MatchIDPacket& a, MatchIDPacket& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MatchIDPacket* New() const final {
    return CreateMaybeMessage<MatchIDPacket>(NULL);
  }

  MatchIDPacket* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MatchIDPacket>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MatchIDPacket& from);
  void MergeFrom(const MatchIDPacket& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchIDPacket* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string user_token = 1;
  void clear_user_token();
  static const int kUserTokenFieldNumber = 1;
  const ::std::string& user_token() const;
  void set_user_token(const ::std::string& value);
  #if LANG_CXX11
  void set_user_token(::std::string&& value);
  #endif
  void set_user_token(const char* value);
  void set_user_token(const char* value, size_t size);
  ::std::string* mutable_user_token();
  ::std::string* release_user_token();
  void set_allocated_user_token(::std::string* user_token);

  // string match_token = 2;
  void clear_match_token();
  static const int kMatchTokenFieldNumber = 2;
  const ::std::string& match_token() const;
  void set_match_token(const ::std::string& value);
  #if LANG_CXX11
  void set_match_token(::std::string&& value);
  #endif
  void set_match_token(const char* value);
  void set_match_token(const char* value, size_t size);
  ::std::string* mutable_match_token();
  ::std::string* release_match_token();
  void set_allocated_match_token(::std::string* match_token);

  // @@protoc_insertion_point(class_scope:netcode.MatchIDPacket)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr user_token_;
  ::google::protobuf::internal::ArenaStringPtr match_token_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_netcode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetTimeoutResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netcode.GetTimeoutResponse) */ {
 public:
  GetTimeoutResponse();
  virtual ~GetTimeoutResponse();

  GetTimeoutResponse(const GetTimeoutResponse& from);

  inline GetTimeoutResponse& operator=(const GetTimeoutResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetTimeoutResponse(GetTimeoutResponse&& from) noexcept
    : GetTimeoutResponse() {
    *this = ::std::move(from);
  }

  inline GetTimeoutResponse& operator=(GetTimeoutResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetTimeoutResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetTimeoutResponse* internal_default_instance() {
    return reinterpret_cast<const GetTimeoutResponse*>(
               &_GetTimeoutResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(GetTimeoutResponse* other);
  friend void swap(GetTimeoutResponse& a, GetTimeoutResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetTimeoutResponse* New() const final {
    return CreateMaybeMessage<GetTimeoutResponse>(NULL);
  }

  GetTimeoutResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetTimeoutResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetTimeoutResponse& from);
  void MergeFrom(const GetTimeoutResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTimeoutResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 timeout_seconds = 1;
  void clear_timeout_seconds();
  static const int kTimeoutSecondsFieldNumber = 1;
  ::google::protobuf::uint32 timeout_seconds() const;
  void set_timeout_seconds(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:netcode.GetTimeoutResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 timeout_seconds_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_netcode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetPseudonymRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netcode.SetPseudonymRequest) */ {
 public:
  SetPseudonymRequest();
  virtual ~SetPseudonymRequest();

  SetPseudonymRequest(const SetPseudonymRequest& from);

  inline SetPseudonymRequest& operator=(const SetPseudonymRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetPseudonymRequest(SetPseudonymRequest&& from) noexcept
    : SetPseudonymRequest() {
    *this = ::std::move(from);
  }

  inline SetPseudonymRequest& operator=(SetPseudonymRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetPseudonymRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetPseudonymRequest* internal_default_instance() {
    return reinterpret_cast<const SetPseudonymRequest*>(
               &_SetPseudonymRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(SetPseudonymRequest* other);
  friend void swap(SetPseudonymRequest& a, SetPseudonymRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetPseudonymRequest* New() const final {
    return CreateMaybeMessage<SetPseudonymRequest>(NULL);
  }

  SetPseudonymRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetPseudonymRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetPseudonymRequest& from);
  void MergeFrom(const SetPseudonymRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetPseudonymRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string pseudonym = 2;
  void clear_pseudonym();
  static const int kPseudonymFieldNumber = 2;
  const ::std::string& pseudonym() const;
  void set_pseudonym(const ::std::string& value);
  #if LANG_CXX11
  void set_pseudonym(::std::string&& value);
  #endif
  void set_pseudonym(const char* value);
  void set_pseudonym(const char* value, size_t size);
  ::std::string* mutable_pseudonym();
  ::std::string* release_pseudonym();
  void set_allocated_pseudonym(::std::string* pseudonym);

  // .netcode.AuthPacket auth = 1;
  bool has_auth() const;
  void clear_auth();
  static const int kAuthFieldNumber = 1;
  private:
  const ::netcode::AuthPacket& _internal_auth() const;
  public:
  const ::netcode::AuthPacket& auth() const;
  ::netcode::AuthPacket* release_auth();
  ::netcode::AuthPacket* mutable_auth();
  void set_allocated_auth(::netcode::AuthPacket* auth);

  // @@protoc_insertion_point(class_scope:netcode.SetPseudonymRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr pseudonym_;
  ::netcode::AuthPacket* auth_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_netcode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetPseudonymResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netcode.SetPseudonymResponse) */ {
 public:
  SetPseudonymResponse();
  virtual ~SetPseudonymResponse();

  SetPseudonymResponse(const SetPseudonymResponse& from);

  inline SetPseudonymResponse& operator=(const SetPseudonymResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetPseudonymResponse(SetPseudonymResponse&& from) noexcept
    : SetPseudonymResponse() {
    *this = ::std::move(from);
  }

  inline SetPseudonymResponse& operator=(SetPseudonymResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetPseudonymResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetPseudonymResponse* internal_default_instance() {
    return reinterpret_cast<const SetPseudonymResponse*>(
               &_SetPseudonymResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(SetPseudonymResponse* other);
  friend void swap(SetPseudonymResponse& a, SetPseudonymResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetPseudonymResponse* New() const final {
    return CreateMaybeMessage<SetPseudonymResponse>(NULL);
  }

  SetPseudonymResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetPseudonymResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetPseudonymResponse& from);
  void MergeFrom(const SetPseudonymResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetPseudonymResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SetPseudonymResponse_ErrorCode ErrorCode;
  static const ErrorCode UNDEFINED_ERROR =
    SetPseudonymResponse_ErrorCode_UNDEFINED_ERROR;
  static const ErrorCode OK =
    SetPseudonymResponse_ErrorCode_OK;
  static const ErrorCode REQUEST_REJECTED =
    SetPseudonymResponse_ErrorCode_REQUEST_REJECTED;
  static const ErrorCode ALREADY_USED =
    SetPseudonymResponse_ErrorCode_ALREADY_USED;
  static const ErrorCode TOO_LONG =
    SetPseudonymResponse_ErrorCode_TOO_LONG;
  static const ErrorCode EMPTY_FIELDS =
    SetPseudonymResponse_ErrorCode_EMPTY_FIELDS;
  static inline bool ErrorCode_IsValid(int value) {
    return SetPseudonymResponse_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    SetPseudonymResponse_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    SetPseudonymResponse_ErrorCode_ErrorCode_MAX;
  static const int ErrorCode_ARRAYSIZE =
    SetPseudonymResponse_ErrorCode_ErrorCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorCode_descriptor() {
    return SetPseudonymResponse_ErrorCode_descriptor();
  }
  static inline const ::std::string& ErrorCode_Name(ErrorCode value) {
    return SetPseudonymResponse_ErrorCode_Name(value);
  }
  static inline bool ErrorCode_Parse(const ::std::string& name,
      ErrorCode* value) {
    return SetPseudonymResponse_ErrorCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .netcode.SetPseudonymResponse.ErrorCode error_code = 1;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  ::netcode::SetPseudonymResponse_ErrorCode error_code() const;
  void set_error_code(::netcode::SetPseudonymResponse_ErrorCode value);

  // @@protoc_insertion_point(class_scope:netcode.SetPseudonymResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int error_code_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_netcode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetUserTokenResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netcode.GetUserTokenResponse) */ {
 public:
  GetUserTokenResponse();
  virtual ~GetUserTokenResponse();

  GetUserTokenResponse(const GetUserTokenResponse& from);

  inline GetUserTokenResponse& operator=(const GetUserTokenResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetUserTokenResponse(GetUserTokenResponse&& from) noexcept
    : GetUserTokenResponse() {
    *this = ::std::move(from);
  }

  inline GetUserTokenResponse& operator=(GetUserTokenResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetUserTokenResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetUserTokenResponse* internal_default_instance() {
    return reinterpret_cast<const GetUserTokenResponse*>(
               &_GetUserTokenResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(GetUserTokenResponse* other);
  friend void swap(GetUserTokenResponse& a, GetUserTokenResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetUserTokenResponse* New() const final {
    return CreateMaybeMessage<GetUserTokenResponse>(NULL);
  }

  GetUserTokenResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetUserTokenResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetUserTokenResponse& from);
  void MergeFrom(const GetUserTokenResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserTokenResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string user_token = 1;
  void clear_user_token();
  static const int kUserTokenFieldNumber = 1;
  const ::std::string& user_token() const;
  void set_user_token(const ::std::string& value);
  #if LANG_CXX11
  void set_user_token(::std::string&& value);
  #endif
  void set_user_token(const char* value);
  void set_user_token(const char* value, size_t size);
  ::std::string* mutable_user_token();
  ::std::string* release_user_token();
  void set_allocated_user_token(::std::string* user_token);

  // @@protoc_insertion_point(class_scope:netcode.GetUserTokenResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr user_token_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_netcode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserRegistrationRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netcode.UserRegistrationRequest) */ {
 public:
  UserRegistrationRequest();
  virtual ~UserRegistrationRequest();

  UserRegistrationRequest(const UserRegistrationRequest& from);

  inline UserRegistrationRequest& operator=(const UserRegistrationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserRegistrationRequest(UserRegistrationRequest&& from) noexcept
    : UserRegistrationRequest() {
    *this = ::std::move(from);
  }

  inline UserRegistrationRequest& operator=(UserRegistrationRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserRegistrationRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserRegistrationRequest* internal_default_instance() {
    return reinterpret_cast<const UserRegistrationRequest*>(
               &_UserRegistrationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(UserRegistrationRequest* other);
  friend void swap(UserRegistrationRequest& a, UserRegistrationRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserRegistrationRequest* New() const final {
    return CreateMaybeMessage<UserRegistrationRequest>(NULL);
  }

  UserRegistrationRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserRegistrationRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserRegistrationRequest& from);
  void MergeFrom(const UserRegistrationRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserRegistrationRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string fullname = 1;
  void clear_fullname();
  static const int kFullnameFieldNumber = 1;
  const ::std::string& fullname() const;
  void set_fullname(const ::std::string& value);
  #if LANG_CXX11
  void set_fullname(::std::string&& value);
  #endif
  void set_fullname(const char* value);
  void set_fullname(const char* value, size_t size);
  ::std::string* mutable_fullname();
  ::std::string* release_fullname();
  void set_allocated_fullname(::std::string* fullname);

  // string email = 2;
  void clear_email();
  static const int kEmailFieldNumber = 2;
  const ::std::string& email() const;
  void set_email(const ::std::string& value);
  #if LANG_CXX11
  void set_email(::std::string&& value);
  #endif
  void set_email(const char* value);
  void set_email(const char* value, size_t size);
  ::std::string* mutable_email();
  ::std::string* release_email();
  void set_allocated_email(::std::string* email);

  // string matr_number = 3;
  void clear_matr_number();
  static const int kMatrNumberFieldNumber = 3;
  const ::std::string& matr_number() const;
  void set_matr_number(const ::std::string& value);
  #if LANG_CXX11
  void set_matr_number(::std::string&& value);
  #endif
  void set_matr_number(const char* value);
  void set_matr_number(const char* value, size_t size);
  ::std::string* mutable_matr_number();
  ::std::string* release_matr_number();
  void set_allocated_matr_number(::std::string* matr_number);

  // string secret = 4;
  void clear_secret();
  static const int kSecretFieldNumber = 4;
  const ::std::string& secret() const;
  void set_secret(const ::std::string& value);
  #if LANG_CXX11
  void set_secret(::std::string&& value);
  #endif
  void set_secret(const char* value);
  void set_secret(const char* value, size_t size);
  ::std::string* mutable_secret();
  ::std::string* release_secret();
  void set_allocated_secret(::std::string* secret);

  // @@protoc_insertion_point(class_scope:netcode.UserRegistrationRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr fullname_;
  ::google::protobuf::internal::ArenaStringPtr email_;
  ::google::protobuf::internal::ArenaStringPtr matr_number_;
  ::google::protobuf::internal::ArenaStringPtr secret_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_netcode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UserRegistrationResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netcode.UserRegistrationResponse) */ {
 public:
  UserRegistrationResponse();
  virtual ~UserRegistrationResponse();

  UserRegistrationResponse(const UserRegistrationResponse& from);

  inline UserRegistrationResponse& operator=(const UserRegistrationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserRegistrationResponse(UserRegistrationResponse&& from) noexcept
    : UserRegistrationResponse() {
    *this = ::std::move(from);
  }

  inline UserRegistrationResponse& operator=(UserRegistrationResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserRegistrationResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserRegistrationResponse* internal_default_instance() {
    return reinterpret_cast<const UserRegistrationResponse*>(
               &_UserRegistrationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(UserRegistrationResponse* other);
  friend void swap(UserRegistrationResponse& a, UserRegistrationResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserRegistrationResponse* New() const final {
    return CreateMaybeMessage<UserRegistrationResponse>(NULL);
  }

  UserRegistrationResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserRegistrationResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserRegistrationResponse& from);
  void MergeFrom(const UserRegistrationResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserRegistrationResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UserRegistrationResponse_ErrorCode ErrorCode;
  static const ErrorCode UNDEFINED_ERROR =
    UserRegistrationResponse_ErrorCode_UNDEFINED_ERROR;
  static const ErrorCode OK =
    UserRegistrationResponse_ErrorCode_OK;
  static const ErrorCode INVALID_PARAMETER =
    UserRegistrationResponse_ErrorCode_INVALID_PARAMETER;
  static const ErrorCode EMPTY_FIELDS =
    UserRegistrationResponse_ErrorCode_EMPTY_FIELDS;
  static const ErrorCode NOT_ALLOWED =
    UserRegistrationResponse_ErrorCode_NOT_ALLOWED;
  static inline bool ErrorCode_IsValid(int value) {
    return UserRegistrationResponse_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    UserRegistrationResponse_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    UserRegistrationResponse_ErrorCode_ErrorCode_MAX;
  static const int ErrorCode_ARRAYSIZE =
    UserRegistrationResponse_ErrorCode_ErrorCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorCode_descriptor() {
    return UserRegistrationResponse_ErrorCode_descriptor();
  }
  static inline const ::std::string& ErrorCode_Name(ErrorCode value) {
    return UserRegistrationResponse_ErrorCode_Name(value);
  }
  static inline bool ErrorCode_Parse(const ::std::string& name,
      ErrorCode* value) {
    return UserRegistrationResponse_ErrorCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .netcode.UserRegistrationResponse.ErrorCode error_code = 1;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  ::netcode::UserRegistrationResponse_ErrorCode error_code() const;
  void set_error_code(::netcode::UserRegistrationResponse_ErrorCode value);

  // @@protoc_insertion_point(class_scope:netcode.UserRegistrationResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int error_code_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_netcode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GroupRegistrationRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netcode.GroupRegistrationRequest) */ {
 public:
  GroupRegistrationRequest();
  virtual ~GroupRegistrationRequest();

  GroupRegistrationRequest(const GroupRegistrationRequest& from);

  inline GroupRegistrationRequest& operator=(const GroupRegistrationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GroupRegistrationRequest(GroupRegistrationRequest&& from) noexcept
    : GroupRegistrationRequest() {
    *this = ::std::move(from);
  }

  inline GroupRegistrationRequest& operator=(GroupRegistrationRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupRegistrationRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GroupRegistrationRequest* internal_default_instance() {
    return reinterpret_cast<const GroupRegistrationRequest*>(
               &_GroupRegistrationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(GroupRegistrationRequest* other);
  friend void swap(GroupRegistrationRequest& a, GroupRegistrationRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GroupRegistrationRequest* New() const final {
    return CreateMaybeMessage<GroupRegistrationRequest>(NULL);
  }

  GroupRegistrationRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GroupRegistrationRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GroupRegistrationRequest& from);
  void MergeFrom(const GroupRegistrationRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupRegistrationRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string matr_number = 2;
  int matr_number_size() const;
  void clear_matr_number();
  static const int kMatrNumberFieldNumber = 2;
  const ::std::string& matr_number(int index) const;
  ::std::string* mutable_matr_number(int index);
  void set_matr_number(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_matr_number(int index, ::std::string&& value);
  #endif
  void set_matr_number(int index, const char* value);
  void set_matr_number(int index, const char* value, size_t size);
  ::std::string* add_matr_number();
  void add_matr_number(const ::std::string& value);
  #if LANG_CXX11
  void add_matr_number(::std::string&& value);
  #endif
  void add_matr_number(const char* value);
  void add_matr_number(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& matr_number() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_matr_number();

  // .netcode.AuthPacket auth = 1;
  bool has_auth() const;
  void clear_auth();
  static const int kAuthFieldNumber = 1;
  private:
  const ::netcode::AuthPacket& _internal_auth() const;
  public:
  const ::netcode::AuthPacket& auth() const;
  ::netcode::AuthPacket* release_auth();
  ::netcode::AuthPacket* mutable_auth();
  void set_allocated_auth(::netcode::AuthPacket* auth);

  // @@protoc_insertion_point(class_scope:netcode.GroupRegistrationRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> matr_number_;
  ::netcode::AuthPacket* auth_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_netcode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GroupRegistrationResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netcode.GroupRegistrationResponse) */ {
 public:
  GroupRegistrationResponse();
  virtual ~GroupRegistrationResponse();

  GroupRegistrationResponse(const GroupRegistrationResponse& from);

  inline GroupRegistrationResponse& operator=(const GroupRegistrationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GroupRegistrationResponse(GroupRegistrationResponse&& from) noexcept
    : GroupRegistrationResponse() {
    *this = ::std::move(from);
  }

  inline GroupRegistrationResponse& operator=(GroupRegistrationResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupRegistrationResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GroupRegistrationResponse* internal_default_instance() {
    return reinterpret_cast<const GroupRegistrationResponse*>(
               &_GroupRegistrationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(GroupRegistrationResponse* other);
  friend void swap(GroupRegistrationResponse& a, GroupRegistrationResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GroupRegistrationResponse* New() const final {
    return CreateMaybeMessage<GroupRegistrationResponse>(NULL);
  }

  GroupRegistrationResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GroupRegistrationResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GroupRegistrationResponse& from);
  void MergeFrom(const GroupRegistrationResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupRegistrationResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GroupRegistrationResponse_ErrorCode ErrorCode;
  static const ErrorCode UNDEFINED_ERROR =
    GroupRegistrationResponse_ErrorCode_UNDEFINED_ERROR;
  static const ErrorCode OK =
    GroupRegistrationResponse_ErrorCode_OK;
  static const ErrorCode UNKNOWN_USER =
    GroupRegistrationResponse_ErrorCode_UNKNOWN_USER;
  static const ErrorCode TOO_MANY_GROUP_MEMBERS =
    GroupRegistrationResponse_ErrorCode_TOO_MANY_GROUP_MEMBERS;
  static const ErrorCode USER_ALREADY_REGISTERED =
    GroupRegistrationResponse_ErrorCode_USER_ALREADY_REGISTERED;
  static const ErrorCode AUTH_FAILED =
    GroupRegistrationResponse_ErrorCode_AUTH_FAILED;
  static inline bool ErrorCode_IsValid(int value) {
    return GroupRegistrationResponse_ErrorCode_IsValid(value);
  }
  static const ErrorCode ErrorCode_MIN =
    GroupRegistrationResponse_ErrorCode_ErrorCode_MIN;
  static const ErrorCode ErrorCode_MAX =
    GroupRegistrationResponse_ErrorCode_ErrorCode_MAX;
  static const int ErrorCode_ARRAYSIZE =
    GroupRegistrationResponse_ErrorCode_ErrorCode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ErrorCode_descriptor() {
    return GroupRegistrationResponse_ErrorCode_descriptor();
  }
  static inline const ::std::string& ErrorCode_Name(ErrorCode value) {
    return GroupRegistrationResponse_ErrorCode_Name(value);
  }
  static inline bool ErrorCode_Parse(const ::std::string& name,
      ErrorCode* value) {
    return GroupRegistrationResponse_ErrorCode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .netcode.GroupRegistrationResponse.ErrorCode error_code = 1;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  ::netcode::GroupRegistrationResponse_ErrorCode error_code() const;
  void set_error_code(::netcode::GroupRegistrationResponse_ErrorCode value);

  // @@protoc_insertion_point(class_scope:netcode.GroupRegistrationResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int error_code_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_netcode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DirectChallenge : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netcode.DirectChallenge) */ {
 public:
  DirectChallenge();
  virtual ~DirectChallenge();

  DirectChallenge(const DirectChallenge& from);

  inline DirectChallenge& operator=(const DirectChallenge& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DirectChallenge(DirectChallenge&& from) noexcept
    : DirectChallenge() {
    *this = ::std::move(from);
  }

  inline DirectChallenge& operator=(DirectChallenge&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DirectChallenge& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DirectChallenge* internal_default_instance() {
    return reinterpret_cast<const DirectChallenge*>(
               &_DirectChallenge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(DirectChallenge* other);
  friend void swap(DirectChallenge& a, DirectChallenge& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DirectChallenge* New() const final {
    return CreateMaybeMessage<DirectChallenge>(NULL);
  }

  DirectChallenge* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DirectChallenge>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DirectChallenge& from);
  void MergeFrom(const DirectChallenge& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DirectChallenge* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string user_pseudonym = 1;
  void clear_user_pseudonym();
  static const int kUserPseudonymFieldNumber = 1;
  const ::std::string& user_pseudonym() const;
  void set_user_pseudonym(const ::std::string& value);
  #if LANG_CXX11
  void set_user_pseudonym(::std::string&& value);
  #endif
  void set_user_pseudonym(const char* value);
  void set_user_pseudonym(const char* value, size_t size);
  ::std::string* mutable_user_pseudonym();
  ::std::string* release_user_pseudonym();
  void set_allocated_user_pseudonym(::std::string* user_pseudonym);

  // @@protoc_insertion_point(class_scope:netcode.DirectChallenge)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr user_pseudonym_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_netcode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MatchmakingParameter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netcode.MatchmakingParameter) */ {
 public:
  MatchmakingParameter();
  virtual ~MatchmakingParameter();

  MatchmakingParameter(const MatchmakingParameter& from);

  inline MatchmakingParameter& operator=(const MatchmakingParameter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MatchmakingParameter(MatchmakingParameter&& from) noexcept
    : MatchmakingParameter() {
    *this = ::std::move(from);
  }

  inline MatchmakingParameter& operator=(MatchmakingParameter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchmakingParameter& default_instance();

  enum ParameterCase {
    kRandomIsDefault = 10,
    kDirectMatchmaking = 11,
    PARAMETER_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MatchmakingParameter* internal_default_instance() {
    return reinterpret_cast<const MatchmakingParameter*>(
               &_MatchmakingParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(MatchmakingParameter* other);
  friend void swap(MatchmakingParameter& a, MatchmakingParameter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MatchmakingParameter* New() const final {
    return CreateMaybeMessage<MatchmakingParameter>(NULL);
  }

  MatchmakingParameter* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MatchmakingParameter>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MatchmakingParameter& from);
  void MergeFrom(const MatchmakingParameter& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchmakingParameter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .netcode.Nothing random_is_default = 10;
  bool has_random_is_default() const;
  void clear_random_is_default();
  static const int kRandomIsDefaultFieldNumber = 10;
  private:
  const ::netcode::Nothing& _internal_random_is_default() const;
  public:
  const ::netcode::Nothing& random_is_default() const;
  ::netcode::Nothing* release_random_is_default();
  ::netcode::Nothing* mutable_random_is_default();
  void set_allocated_random_is_default(::netcode::Nothing* random_is_default);

  // .netcode.DirectChallenge direct_matchmaking = 11;
  bool has_direct_matchmaking() const;
  void clear_direct_matchmaking();
  static const int kDirectMatchmakingFieldNumber = 11;
  private:
  const ::netcode::DirectChallenge& _internal_direct_matchmaking() const;
  public:
  const ::netcode::DirectChallenge& direct_matchmaking() const;
  ::netcode::DirectChallenge* release_direct_matchmaking();
  ::netcode::DirectChallenge* mutable_direct_matchmaking();
  void set_allocated_direct_matchmaking(::netcode::DirectChallenge* direct_matchmaking);

  void clear_parameter();
  ParameterCase parameter_case() const;
  // @@protoc_insertion_point(class_scope:netcode.MatchmakingParameter)
 private:
  void set_has_random_is_default();
  void set_has_direct_matchmaking();

  inline bool has_parameter() const;
  inline void clear_has_parameter();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ParameterUnion {
    ParameterUnion() {}
    ::netcode::Nothing* random_is_default_;
    ::netcode::DirectChallenge* direct_matchmaking_;
  } parameter_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_netcode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MatchRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netcode.MatchRequest) */ {
 public:
  MatchRequest();
  virtual ~MatchRequest();

  MatchRequest(const MatchRequest& from);

  inline MatchRequest& operator=(const MatchRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MatchRequest(MatchRequest&& from) noexcept
    : MatchRequest() {
    *this = ::std::move(from);
  }

  inline MatchRequest& operator=(MatchRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchRequest& default_instance();

  enum GameParametersCase {
    kNimGameParameters = 10,
    kDabGameParameters = 11,
    kDomGameParameters = 12,
    GAME_PARAMETERS_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MatchRequest* internal_default_instance() {
    return reinterpret_cast<const MatchRequest*>(
               &_MatchRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(MatchRequest* other);
  friend void swap(MatchRequest& a, MatchRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MatchRequest* New() const final {
    return CreateMaybeMessage<MatchRequest>(NULL);
  }

  MatchRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MatchRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MatchRequest& from);
  void MergeFrom(const MatchRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string user_token = 1;
  void clear_user_token();
  static const int kUserTokenFieldNumber = 1;
  const ::std::string& user_token() const;
  void set_user_token(const ::std::string& value);
  #if LANG_CXX11
  void set_user_token(::std::string&& value);
  #endif
  void set_user_token(const char* value);
  void set_user_token(const char* value, size_t size);
  ::std::string* mutable_user_token();
  ::std::string* release_user_token();
  void set_allocated_user_token(::std::string* user_token);

  // string game_token = 2;
  void clear_game_token();
  static const int kGameTokenFieldNumber = 2;
  const ::std::string& game_token() const;
  void set_game_token(const ::std::string& value);
  #if LANG_CXX11
  void set_game_token(::std::string&& value);
  #endif
  void set_game_token(const char* value);
  void set_game_token(const char* value, size_t size);
  ::std::string* mutable_game_token();
  ::std::string* release_game_token();
  void set_allocated_game_token(::std::string* game_token);

  // .netcode.MatchmakingParameter matchmaking_parameters = 3;
  bool has_matchmaking_parameters() const;
  void clear_matchmaking_parameters();
  static const int kMatchmakingParametersFieldNumber = 3;
  private:
  const ::netcode::MatchmakingParameter& _internal_matchmaking_parameters() const;
  public:
  const ::netcode::MatchmakingParameter& matchmaking_parameters() const;
  ::netcode::MatchmakingParameter* release_matchmaking_parameters();
  ::netcode::MatchmakingParameter* mutable_matchmaking_parameters();
  void set_allocated_matchmaking_parameters(::netcode::MatchmakingParameter* matchmaking_parameters);

  // uint32 timeout_suggestion_seconds = 4;
  void clear_timeout_suggestion_seconds();
  static const int kTimeoutSuggestionSecondsFieldNumber = 4;
  ::google::protobuf::uint32 timeout_suggestion_seconds() const;
  void set_timeout_suggestion_seconds(::google::protobuf::uint32 value);

  // .nim.GameParameter nim_game_parameters = 10;
  bool has_nim_game_parameters() const;
  void clear_nim_game_parameters();
  static const int kNimGameParametersFieldNumber = 10;
  private:
  const ::nim::GameParameter& _internal_nim_game_parameters() const;
  public:
  const ::nim::GameParameter& nim_game_parameters() const;
  ::nim::GameParameter* release_nim_game_parameters();
  ::nim::GameParameter* mutable_nim_game_parameters();
  void set_allocated_nim_game_parameters(::nim::GameParameter* nim_game_parameters);

  // .dab.GameParameter dab_game_parameters = 11;
  bool has_dab_game_parameters() const;
  void clear_dab_game_parameters();
  static const int kDabGameParametersFieldNumber = 11;
  private:
  const ::dab::GameParameter& _internal_dab_game_parameters() const;
  public:
  const ::dab::GameParameter& dab_game_parameters() const;
  ::dab::GameParameter* release_dab_game_parameters();
  ::dab::GameParameter* mutable_dab_game_parameters();
  void set_allocated_dab_game_parameters(::dab::GameParameter* dab_game_parameters);

  // .dom.GameParameter dom_game_parameters = 12;
  bool has_dom_game_parameters() const;
  void clear_dom_game_parameters();
  static const int kDomGameParametersFieldNumber = 12;
  private:
  const ::dom::GameParameter& _internal_dom_game_parameters() const;
  public:
  const ::dom::GameParameter& dom_game_parameters() const;
  ::dom::GameParameter* release_dom_game_parameters();
  ::dom::GameParameter* mutable_dom_game_parameters();
  void set_allocated_dom_game_parameters(::dom::GameParameter* dom_game_parameters);

  void clear_game_parameters();
  GameParametersCase game_parameters_case() const;
  // @@protoc_insertion_point(class_scope:netcode.MatchRequest)
 private:
  void set_has_nim_game_parameters();
  void set_has_dab_game_parameters();
  void set_has_dom_game_parameters();

  inline bool has_game_parameters() const;
  inline void clear_has_game_parameters();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr user_token_;
  ::google::protobuf::internal::ArenaStringPtr game_token_;
  ::netcode::MatchmakingParameter* matchmaking_parameters_;
  ::google::protobuf::uint32 timeout_suggestion_seconds_;
  union GameParametersUnion {
    GameParametersUnion() {}
    ::nim::GameParameter* nim_game_parameters_;
    ::dab::GameParameter* dab_game_parameters_;
    ::dom::GameParameter* dom_game_parameters_;
  } game_parameters_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_netcode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MatchResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netcode.MatchResponse) */ {
 public:
  MatchResponse();
  virtual ~MatchResponse();

  MatchResponse(const MatchResponse& from);

  inline MatchResponse& operator=(const MatchResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MatchResponse(MatchResponse&& from) noexcept
    : MatchResponse() {
    *this = ::std::move(from);
  }

  inline MatchResponse& operator=(MatchResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MatchResponse* internal_default_instance() {
    return reinterpret_cast<const MatchResponse*>(
               &_MatchResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(MatchResponse* other);
  friend void swap(MatchResponse& a, MatchResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MatchResponse* New() const final {
    return CreateMaybeMessage<MatchResponse>(NULL);
  }

  MatchResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MatchResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MatchResponse& from);
  void MergeFrom(const MatchResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string match_token = 1;
  void clear_match_token();
  static const int kMatchTokenFieldNumber = 1;
  const ::std::string& match_token() const;
  void set_match_token(const ::std::string& value);
  #if LANG_CXX11
  void set_match_token(::std::string&& value);
  #endif
  void set_match_token(const char* value);
  void set_match_token(const char* value, size_t size);
  ::std::string* mutable_match_token();
  ::std::string* release_match_token();
  void set_allocated_match_token(::std::string* match_token);

  // bool beginning_player = 2;
  void clear_beginning_player();
  static const int kBeginningPlayerFieldNumber = 2;
  bool beginning_player() const;
  void set_beginning_player(bool value);

  // @@protoc_insertion_point(class_scope:netcode.MatchResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr match_token_;
  bool beginning_player_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_netcode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TurnRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netcode.TurnRequest) */ {
 public:
  TurnRequest();
  virtual ~TurnRequest();

  TurnRequest(const TurnRequest& from);

  inline TurnRequest& operator=(const TurnRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TurnRequest(TurnRequest&& from) noexcept
    : TurnRequest() {
    *this = ::std::move(from);
  }

  inline TurnRequest& operator=(TurnRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TurnRequest& default_instance();

  enum GameTurnCase {
    kNimGameTurn = 10,
    kDabGameTurn = 11,
    kDomGameTurn = 12,
    GAME_TURN_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TurnRequest* internal_default_instance() {
    return reinterpret_cast<const TurnRequest*>(
               &_TurnRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(TurnRequest* other);
  friend void swap(TurnRequest& a, TurnRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TurnRequest* New() const final {
    return CreateMaybeMessage<TurnRequest>(NULL);
  }

  TurnRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TurnRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TurnRequest& from);
  void MergeFrom(const TurnRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TurnRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .netcode.MatchIDPacket match_id = 1;
  bool has_match_id() const;
  void clear_match_id();
  static const int kMatchIdFieldNumber = 1;
  private:
  const ::netcode::MatchIDPacket& _internal_match_id() const;
  public:
  const ::netcode::MatchIDPacket& match_id() const;
  ::netcode::MatchIDPacket* release_match_id();
  ::netcode::MatchIDPacket* mutable_match_id();
  void set_allocated_match_id(::netcode::MatchIDPacket* match_id);

  // .nim.GameTurn nim_game_turn = 10;
  bool has_nim_game_turn() const;
  void clear_nim_game_turn();
  static const int kNimGameTurnFieldNumber = 10;
  private:
  const ::nim::GameTurn& _internal_nim_game_turn() const;
  public:
  const ::nim::GameTurn& nim_game_turn() const;
  ::nim::GameTurn* release_nim_game_turn();
  ::nim::GameTurn* mutable_nim_game_turn();
  void set_allocated_nim_game_turn(::nim::GameTurn* nim_game_turn);

  // .dab.GameTurn dab_game_turn = 11;
  bool has_dab_game_turn() const;
  void clear_dab_game_turn();
  static const int kDabGameTurnFieldNumber = 11;
  private:
  const ::dab::GameTurn& _internal_dab_game_turn() const;
  public:
  const ::dab::GameTurn& dab_game_turn() const;
  ::dab::GameTurn* release_dab_game_turn();
  ::dab::GameTurn* mutable_dab_game_turn();
  void set_allocated_dab_game_turn(::dab::GameTurn* dab_game_turn);

  // .dom.GameTurn dom_game_turn = 12;
  bool has_dom_game_turn() const;
  void clear_dom_game_turn();
  static const int kDomGameTurnFieldNumber = 12;
  private:
  const ::dom::GameTurn& _internal_dom_game_turn() const;
  public:
  const ::dom::GameTurn& dom_game_turn() const;
  ::dom::GameTurn* release_dom_game_turn();
  ::dom::GameTurn* mutable_dom_game_turn();
  void set_allocated_dom_game_turn(::dom::GameTurn* dom_game_turn);

  void clear_game_turn();
  GameTurnCase game_turn_case() const;
  // @@protoc_insertion_point(class_scope:netcode.TurnRequest)
 private:
  void set_has_nim_game_turn();
  void set_has_dab_game_turn();
  void set_has_dom_game_turn();

  inline bool has_game_turn() const;
  inline void clear_has_game_turn();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::netcode::MatchIDPacket* match_id_;
  union GameTurnUnion {
    GameTurnUnion() {}
    ::nim::GameTurn* nim_game_turn_;
    ::dab::GameTurn* dab_game_turn_;
    ::dom::GameTurn* dom_game_turn_;
  } game_turn_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_netcode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TurnResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netcode.TurnResponse) */ {
 public:
  TurnResponse();
  virtual ~TurnResponse();

  TurnResponse(const TurnResponse& from);

  inline TurnResponse& operator=(const TurnResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TurnResponse(TurnResponse&& from) noexcept
    : TurnResponse() {
    *this = ::std::move(from);
  }

  inline TurnResponse& operator=(TurnResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TurnResponse& default_instance();

  enum GameStateCase {
    kNimGameState = 10,
    kDabGameState = 11,
    kDomGameState = 12,
    GAME_STATE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TurnResponse* internal_default_instance() {
    return reinterpret_cast<const TurnResponse*>(
               &_TurnResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(TurnResponse* other);
  friend void swap(TurnResponse& a, TurnResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TurnResponse* New() const final {
    return CreateMaybeMessage<TurnResponse>(NULL);
  }

  TurnResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TurnResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TurnResponse& from);
  void MergeFrom(const TurnResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TurnResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .netcode.TurnStatus turn_status = 1;
  void clear_turn_status();
  static const int kTurnStatusFieldNumber = 1;
  ::netcode::TurnStatus turn_status() const;
  void set_turn_status(::netcode::TurnStatus value);

  // .nim.GameState nim_game_state = 10;
  bool has_nim_game_state() const;
  void clear_nim_game_state();
  static const int kNimGameStateFieldNumber = 10;
  private:
  const ::nim::GameState& _internal_nim_game_state() const;
  public:
  const ::nim::GameState& nim_game_state() const;
  ::nim::GameState* release_nim_game_state();
  ::nim::GameState* mutable_nim_game_state();
  void set_allocated_nim_game_state(::nim::GameState* nim_game_state);

  // .dab.GameState dab_game_state = 11;
  bool has_dab_game_state() const;
  void clear_dab_game_state();
  static const int kDabGameStateFieldNumber = 11;
  private:
  const ::dab::GameState& _internal_dab_game_state() const;
  public:
  const ::dab::GameState& dab_game_state() const;
  ::dab::GameState* release_dab_game_state();
  ::dab::GameState* mutable_dab_game_state();
  void set_allocated_dab_game_state(::dab::GameState* dab_game_state);

  // .dom.GameState dom_game_state = 12;
  bool has_dom_game_state() const;
  void clear_dom_game_state();
  static const int kDomGameStateFieldNumber = 12;
  private:
  const ::dom::GameState& _internal_dom_game_state() const;
  public:
  const ::dom::GameState& dom_game_state() const;
  ::dom::GameState* release_dom_game_state();
  ::dom::GameState* mutable_dom_game_state();
  void set_allocated_dom_game_state(::dom::GameState* dom_game_state);

  void clear_game_state();
  GameStateCase game_state_case() const;
  // @@protoc_insertion_point(class_scope:netcode.TurnResponse)
 private:
  void set_has_nim_game_state();
  void set_has_dab_game_state();
  void set_has_dom_game_state();

  inline bool has_game_state() const;
  inline void clear_has_game_state();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int turn_status_;
  union GameStateUnion {
    GameStateUnion() {}
    ::nim::GameState* nim_game_state_;
    ::dab::GameState* dab_game_state_;
    ::dom::GameState* dom_game_state_;
  } game_state_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_netcode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GameStateResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netcode.GameStateResponse) */ {
 public:
  GameStateResponse();
  virtual ~GameStateResponse();

  GameStateResponse(const GameStateResponse& from);

  inline GameStateResponse& operator=(const GameStateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameStateResponse(GameStateResponse&& from) noexcept
    : GameStateResponse() {
    *this = ::std::move(from);
  }

  inline GameStateResponse& operator=(GameStateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GameStateResponse& default_instance();

  enum GameStateCase {
    kNimGameState = 10,
    kDabGameState = 11,
    kDomGameState = 12,
    GAME_STATE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameStateResponse* internal_default_instance() {
    return reinterpret_cast<const GameStateResponse*>(
               &_GameStateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(GameStateResponse* other);
  friend void swap(GameStateResponse& a, GameStateResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameStateResponse* New() const final {
    return CreateMaybeMessage<GameStateResponse>(NULL);
  }

  GameStateResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GameStateResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GameStateResponse& from);
  void MergeFrom(const GameStateResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameStateResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .netcode.GameStatus game_status = 1;
  void clear_game_status();
  static const int kGameStatusFieldNumber = 1;
  ::netcode::GameStatus game_status() const;
  void set_game_status(::netcode::GameStatus value);

  // bool beginning_player = 2;
  void clear_beginning_player();
  static const int kBeginningPlayerFieldNumber = 2;
  bool beginning_player() const;
  void set_beginning_player(bool value);

  // .nim.GameState nim_game_state = 10;
  bool has_nim_game_state() const;
  void clear_nim_game_state();
  static const int kNimGameStateFieldNumber = 10;
  private:
  const ::nim::GameState& _internal_nim_game_state() const;
  public:
  const ::nim::GameState& nim_game_state() const;
  ::nim::GameState* release_nim_game_state();
  ::nim::GameState* mutable_nim_game_state();
  void set_allocated_nim_game_state(::nim::GameState* nim_game_state);

  // .dab.GameState dab_game_state = 11;
  bool has_dab_game_state() const;
  void clear_dab_game_state();
  static const int kDabGameStateFieldNumber = 11;
  private:
  const ::dab::GameState& _internal_dab_game_state() const;
  public:
  const ::dab::GameState& dab_game_state() const;
  ::dab::GameState* release_dab_game_state();
  ::dab::GameState* mutable_dab_game_state();
  void set_allocated_dab_game_state(::dab::GameState* dab_game_state);

  // .dom.GameState dom_game_state = 12;
  bool has_dom_game_state() const;
  void clear_dom_game_state();
  static const int kDomGameStateFieldNumber = 12;
  private:
  const ::dom::GameState& _internal_dom_game_state() const;
  public:
  const ::dom::GameState& dom_game_state() const;
  ::dom::GameState* release_dom_game_state();
  ::dom::GameState* mutable_dom_game_state();
  void set_allocated_dom_game_state(::dom::GameState* dom_game_state);

  void clear_game_state();
  GameStateCase game_state_case() const;
  // @@protoc_insertion_point(class_scope:netcode.GameStateResponse)
 private:
  void set_has_nim_game_state();
  void set_has_dab_game_state();
  void set_has_dom_game_state();

  inline bool has_game_state() const;
  inline void clear_has_game_state();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int game_status_;
  bool beginning_player_;
  union GameStateUnion {
    GameStateUnion() {}
    ::nim::GameState* nim_game_state_;
    ::dab::GameState* dab_game_state_;
    ::dom::GameState* dom_game_state_;
  } game_state_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_netcode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OpponentInfoResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netcode.OpponentInfoResponse) */ {
 public:
  OpponentInfoResponse();
  virtual ~OpponentInfoResponse();

  OpponentInfoResponse(const OpponentInfoResponse& from);

  inline OpponentInfoResponse& operator=(const OpponentInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OpponentInfoResponse(OpponentInfoResponse&& from) noexcept
    : OpponentInfoResponse() {
    *this = ::std::move(from);
  }

  inline OpponentInfoResponse& operator=(OpponentInfoResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OpponentInfoResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OpponentInfoResponse* internal_default_instance() {
    return reinterpret_cast<const OpponentInfoResponse*>(
               &_OpponentInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(OpponentInfoResponse* other);
  friend void swap(OpponentInfoResponse& a, OpponentInfoResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OpponentInfoResponse* New() const final {
    return CreateMaybeMessage<OpponentInfoResponse>(NULL);
  }

  OpponentInfoResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OpponentInfoResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OpponentInfoResponse& from);
  void MergeFrom(const OpponentInfoResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpponentInfoResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string user_pseudonym = 1;
  void clear_user_pseudonym();
  static const int kUserPseudonymFieldNumber = 1;
  const ::std::string& user_pseudonym() const;
  void set_user_pseudonym(const ::std::string& value);
  #if LANG_CXX11
  void set_user_pseudonym(::std::string&& value);
  #endif
  void set_user_pseudonym(const char* value);
  void set_user_pseudonym(const char* value, size_t size);
  ::std::string* mutable_user_pseudonym();
  ::std::string* release_user_pseudonym();
  void set_allocated_user_pseudonym(::std::string* user_pseudonym);

  // string group_pseudonym = 2;
  void clear_group_pseudonym();
  static const int kGroupPseudonymFieldNumber = 2;
  const ::std::string& group_pseudonym() const;
  void set_group_pseudonym(const ::std::string& value);
  #if LANG_CXX11
  void set_group_pseudonym(::std::string&& value);
  #endif
  void set_group_pseudonym(const char* value);
  void set_group_pseudonym(const char* value, size_t size);
  ::std::string* mutable_group_pseudonym();
  ::std::string* release_group_pseudonym();
  void set_allocated_group_pseudonym(::std::string* group_pseudonym);

  // @@protoc_insertion_point(class_scope:netcode.OpponentInfoResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr user_pseudonym_;
  ::google::protobuf::internal::ArenaStringPtr group_pseudonym_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_netcode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Nothing : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:netcode.Nothing) */ {
 public:
  Nothing();
  virtual ~Nothing();

  Nothing(const Nothing& from);

  inline Nothing& operator=(const Nothing& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Nothing(Nothing&& from) noexcept
    : Nothing() {
    *this = ::std::move(from);
  }

  inline Nothing& operator=(Nothing&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Nothing& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Nothing* internal_default_instance() {
    return reinterpret_cast<const Nothing*>(
               &_Nothing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(Nothing* other);
  friend void swap(Nothing& a, Nothing& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Nothing* New() const final {
    return CreateMaybeMessage<Nothing>(NULL);
  }

  Nothing* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Nothing>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Nothing& from);
  void MergeFrom(const Nothing& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Nothing* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:netcode.Nothing)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_netcode_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AuthPacket

// string matr_number = 1;
inline void AuthPacket::clear_matr_number() {
  matr_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuthPacket::matr_number() const {
  // @@protoc_insertion_point(field_get:netcode.AuthPacket.matr_number)
  return matr_number_.GetNoArena();
}
inline void AuthPacket::set_matr_number(const ::std::string& value) {
  
  matr_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netcode.AuthPacket.matr_number)
}
#if LANG_CXX11
inline void AuthPacket::set_matr_number(::std::string&& value) {
  
  matr_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netcode.AuthPacket.matr_number)
}
#endif
inline void AuthPacket::set_matr_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  matr_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netcode.AuthPacket.matr_number)
}
inline void AuthPacket::set_matr_number(const char* value, size_t size) {
  
  matr_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netcode.AuthPacket.matr_number)
}
inline ::std::string* AuthPacket::mutable_matr_number() {
  
  // @@protoc_insertion_point(field_mutable:netcode.AuthPacket.matr_number)
  return matr_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthPacket::release_matr_number() {
  // @@protoc_insertion_point(field_release:netcode.AuthPacket.matr_number)
  
  return matr_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthPacket::set_allocated_matr_number(::std::string* matr_number) {
  if (matr_number != NULL) {
    
  } else {
    
  }
  matr_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), matr_number);
  // @@protoc_insertion_point(field_set_allocated:netcode.AuthPacket.matr_number)
}

// string secret = 2;
inline void AuthPacket::clear_secret() {
  secret_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuthPacket::secret() const {
  // @@protoc_insertion_point(field_get:netcode.AuthPacket.secret)
  return secret_.GetNoArena();
}
inline void AuthPacket::set_secret(const ::std::string& value) {
  
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netcode.AuthPacket.secret)
}
#if LANG_CXX11
inline void AuthPacket::set_secret(::std::string&& value) {
  
  secret_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netcode.AuthPacket.secret)
}
#endif
inline void AuthPacket::set_secret(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netcode.AuthPacket.secret)
}
inline void AuthPacket::set_secret(const char* value, size_t size) {
  
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netcode.AuthPacket.secret)
}
inline ::std::string* AuthPacket::mutable_secret() {
  
  // @@protoc_insertion_point(field_mutable:netcode.AuthPacket.secret)
  return secret_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuthPacket::release_secret() {
  // @@protoc_insertion_point(field_release:netcode.AuthPacket.secret)
  
  return secret_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuthPacket::set_allocated_secret(::std::string* secret) {
  if (secret != NULL) {
    
  } else {
    
  }
  secret_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), secret);
  // @@protoc_insertion_point(field_set_allocated:netcode.AuthPacket.secret)
}

// -------------------------------------------------------------------

// MatchIDPacket

// string user_token = 1;
inline void MatchIDPacket::clear_user_token() {
  user_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MatchIDPacket::user_token() const {
  // @@protoc_insertion_point(field_get:netcode.MatchIDPacket.user_token)
  return user_token_.GetNoArena();
}
inline void MatchIDPacket::set_user_token(const ::std::string& value) {
  
  user_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netcode.MatchIDPacket.user_token)
}
#if LANG_CXX11
inline void MatchIDPacket::set_user_token(::std::string&& value) {
  
  user_token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netcode.MatchIDPacket.user_token)
}
#endif
inline void MatchIDPacket::set_user_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  user_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netcode.MatchIDPacket.user_token)
}
inline void MatchIDPacket::set_user_token(const char* value, size_t size) {
  
  user_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netcode.MatchIDPacket.user_token)
}
inline ::std::string* MatchIDPacket::mutable_user_token() {
  
  // @@protoc_insertion_point(field_mutable:netcode.MatchIDPacket.user_token)
  return user_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MatchIDPacket::release_user_token() {
  // @@protoc_insertion_point(field_release:netcode.MatchIDPacket.user_token)
  
  return user_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MatchIDPacket::set_allocated_user_token(::std::string* user_token) {
  if (user_token != NULL) {
    
  } else {
    
  }
  user_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_token);
  // @@protoc_insertion_point(field_set_allocated:netcode.MatchIDPacket.user_token)
}

// string match_token = 2;
inline void MatchIDPacket::clear_match_token() {
  match_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MatchIDPacket::match_token() const {
  // @@protoc_insertion_point(field_get:netcode.MatchIDPacket.match_token)
  return match_token_.GetNoArena();
}
inline void MatchIDPacket::set_match_token(const ::std::string& value) {
  
  match_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netcode.MatchIDPacket.match_token)
}
#if LANG_CXX11
inline void MatchIDPacket::set_match_token(::std::string&& value) {
  
  match_token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netcode.MatchIDPacket.match_token)
}
#endif
inline void MatchIDPacket::set_match_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  match_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netcode.MatchIDPacket.match_token)
}
inline void MatchIDPacket::set_match_token(const char* value, size_t size) {
  
  match_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netcode.MatchIDPacket.match_token)
}
inline ::std::string* MatchIDPacket::mutable_match_token() {
  
  // @@protoc_insertion_point(field_mutable:netcode.MatchIDPacket.match_token)
  return match_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MatchIDPacket::release_match_token() {
  // @@protoc_insertion_point(field_release:netcode.MatchIDPacket.match_token)
  
  return match_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MatchIDPacket::set_allocated_match_token(::std::string* match_token) {
  if (match_token != NULL) {
    
  } else {
    
  }
  match_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), match_token);
  // @@protoc_insertion_point(field_set_allocated:netcode.MatchIDPacket.match_token)
}

// -------------------------------------------------------------------

// GetTimeoutResponse

// uint32 timeout_seconds = 1;
inline void GetTimeoutResponse::clear_timeout_seconds() {
  timeout_seconds_ = 0u;
}
inline ::google::protobuf::uint32 GetTimeoutResponse::timeout_seconds() const {
  // @@protoc_insertion_point(field_get:netcode.GetTimeoutResponse.timeout_seconds)
  return timeout_seconds_;
}
inline void GetTimeoutResponse::set_timeout_seconds(::google::protobuf::uint32 value) {
  
  timeout_seconds_ = value;
  // @@protoc_insertion_point(field_set:netcode.GetTimeoutResponse.timeout_seconds)
}

// -------------------------------------------------------------------

// SetPseudonymRequest

// .netcode.AuthPacket auth = 1;
inline bool SetPseudonymRequest::has_auth() const {
  return this != internal_default_instance() && auth_ != NULL;
}
inline void SetPseudonymRequest::clear_auth() {
  if (GetArenaNoVirtual() == NULL && auth_ != NULL) {
    delete auth_;
  }
  auth_ = NULL;
}
inline const ::netcode::AuthPacket& SetPseudonymRequest::_internal_auth() const {
  return *auth_;
}
inline const ::netcode::AuthPacket& SetPseudonymRequest::auth() const {
  const ::netcode::AuthPacket* p = auth_;
  // @@protoc_insertion_point(field_get:netcode.SetPseudonymRequest.auth)
  return p != NULL ? *p : *reinterpret_cast<const ::netcode::AuthPacket*>(
      &::netcode::_AuthPacket_default_instance_);
}
inline ::netcode::AuthPacket* SetPseudonymRequest::release_auth() {
  // @@protoc_insertion_point(field_release:netcode.SetPseudonymRequest.auth)
  
  ::netcode::AuthPacket* temp = auth_;
  auth_ = NULL;
  return temp;
}
inline ::netcode::AuthPacket* SetPseudonymRequest::mutable_auth() {
  
  if (auth_ == NULL) {
    auto* p = CreateMaybeMessage<::netcode::AuthPacket>(GetArenaNoVirtual());
    auth_ = p;
  }
  // @@protoc_insertion_point(field_mutable:netcode.SetPseudonymRequest.auth)
  return auth_;
}
inline void SetPseudonymRequest::set_allocated_auth(::netcode::AuthPacket* auth) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete auth_;
  }
  if (auth) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      auth = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, auth, submessage_arena);
    }
    
  } else {
    
  }
  auth_ = auth;
  // @@protoc_insertion_point(field_set_allocated:netcode.SetPseudonymRequest.auth)
}

// string pseudonym = 2;
inline void SetPseudonymRequest::clear_pseudonym() {
  pseudonym_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SetPseudonymRequest::pseudonym() const {
  // @@protoc_insertion_point(field_get:netcode.SetPseudonymRequest.pseudonym)
  return pseudonym_.GetNoArena();
}
inline void SetPseudonymRequest::set_pseudonym(const ::std::string& value) {
  
  pseudonym_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netcode.SetPseudonymRequest.pseudonym)
}
#if LANG_CXX11
inline void SetPseudonymRequest::set_pseudonym(::std::string&& value) {
  
  pseudonym_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netcode.SetPseudonymRequest.pseudonym)
}
#endif
inline void SetPseudonymRequest::set_pseudonym(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pseudonym_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netcode.SetPseudonymRequest.pseudonym)
}
inline void SetPseudonymRequest::set_pseudonym(const char* value, size_t size) {
  
  pseudonym_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netcode.SetPseudonymRequest.pseudonym)
}
inline ::std::string* SetPseudonymRequest::mutable_pseudonym() {
  
  // @@protoc_insertion_point(field_mutable:netcode.SetPseudonymRequest.pseudonym)
  return pseudonym_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetPseudonymRequest::release_pseudonym() {
  // @@protoc_insertion_point(field_release:netcode.SetPseudonymRequest.pseudonym)
  
  return pseudonym_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetPseudonymRequest::set_allocated_pseudonym(::std::string* pseudonym) {
  if (pseudonym != NULL) {
    
  } else {
    
  }
  pseudonym_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pseudonym);
  // @@protoc_insertion_point(field_set_allocated:netcode.SetPseudonymRequest.pseudonym)
}

// -------------------------------------------------------------------

// SetPseudonymResponse

// .netcode.SetPseudonymResponse.ErrorCode error_code = 1;
inline void SetPseudonymResponse::clear_error_code() {
  error_code_ = 0;
}
inline ::netcode::SetPseudonymResponse_ErrorCode SetPseudonymResponse::error_code() const {
  // @@protoc_insertion_point(field_get:netcode.SetPseudonymResponse.error_code)
  return static_cast< ::netcode::SetPseudonymResponse_ErrorCode >(error_code_);
}
inline void SetPseudonymResponse::set_error_code(::netcode::SetPseudonymResponse_ErrorCode value) {
  
  error_code_ = value;
  // @@protoc_insertion_point(field_set:netcode.SetPseudonymResponse.error_code)
}

// -------------------------------------------------------------------

// GetUserTokenResponse

// string user_token = 1;
inline void GetUserTokenResponse::clear_user_token() {
  user_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetUserTokenResponse::user_token() const {
  // @@protoc_insertion_point(field_get:netcode.GetUserTokenResponse.user_token)
  return user_token_.GetNoArena();
}
inline void GetUserTokenResponse::set_user_token(const ::std::string& value) {
  
  user_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netcode.GetUserTokenResponse.user_token)
}
#if LANG_CXX11
inline void GetUserTokenResponse::set_user_token(::std::string&& value) {
  
  user_token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netcode.GetUserTokenResponse.user_token)
}
#endif
inline void GetUserTokenResponse::set_user_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  user_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netcode.GetUserTokenResponse.user_token)
}
inline void GetUserTokenResponse::set_user_token(const char* value, size_t size) {
  
  user_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netcode.GetUserTokenResponse.user_token)
}
inline ::std::string* GetUserTokenResponse::mutable_user_token() {
  
  // @@protoc_insertion_point(field_mutable:netcode.GetUserTokenResponse.user_token)
  return user_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetUserTokenResponse::release_user_token() {
  // @@protoc_insertion_point(field_release:netcode.GetUserTokenResponse.user_token)
  
  return user_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetUserTokenResponse::set_allocated_user_token(::std::string* user_token) {
  if (user_token != NULL) {
    
  } else {
    
  }
  user_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_token);
  // @@protoc_insertion_point(field_set_allocated:netcode.GetUserTokenResponse.user_token)
}

// -------------------------------------------------------------------

// UserRegistrationRequest

// string fullname = 1;
inline void UserRegistrationRequest::clear_fullname() {
  fullname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserRegistrationRequest::fullname() const {
  // @@protoc_insertion_point(field_get:netcode.UserRegistrationRequest.fullname)
  return fullname_.GetNoArena();
}
inline void UserRegistrationRequest::set_fullname(const ::std::string& value) {
  
  fullname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netcode.UserRegistrationRequest.fullname)
}
#if LANG_CXX11
inline void UserRegistrationRequest::set_fullname(::std::string&& value) {
  
  fullname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netcode.UserRegistrationRequest.fullname)
}
#endif
inline void UserRegistrationRequest::set_fullname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  fullname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netcode.UserRegistrationRequest.fullname)
}
inline void UserRegistrationRequest::set_fullname(const char* value, size_t size) {
  
  fullname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netcode.UserRegistrationRequest.fullname)
}
inline ::std::string* UserRegistrationRequest::mutable_fullname() {
  
  // @@protoc_insertion_point(field_mutable:netcode.UserRegistrationRequest.fullname)
  return fullname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserRegistrationRequest::release_fullname() {
  // @@protoc_insertion_point(field_release:netcode.UserRegistrationRequest.fullname)
  
  return fullname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserRegistrationRequest::set_allocated_fullname(::std::string* fullname) {
  if (fullname != NULL) {
    
  } else {
    
  }
  fullname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fullname);
  // @@protoc_insertion_point(field_set_allocated:netcode.UserRegistrationRequest.fullname)
}

// string email = 2;
inline void UserRegistrationRequest::clear_email() {
  email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserRegistrationRequest::email() const {
  // @@protoc_insertion_point(field_get:netcode.UserRegistrationRequest.email)
  return email_.GetNoArena();
}
inline void UserRegistrationRequest::set_email(const ::std::string& value) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netcode.UserRegistrationRequest.email)
}
#if LANG_CXX11
inline void UserRegistrationRequest::set_email(::std::string&& value) {
  
  email_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netcode.UserRegistrationRequest.email)
}
#endif
inline void UserRegistrationRequest::set_email(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netcode.UserRegistrationRequest.email)
}
inline void UserRegistrationRequest::set_email(const char* value, size_t size) {
  
  email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netcode.UserRegistrationRequest.email)
}
inline ::std::string* UserRegistrationRequest::mutable_email() {
  
  // @@protoc_insertion_point(field_mutable:netcode.UserRegistrationRequest.email)
  return email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserRegistrationRequest::release_email() {
  // @@protoc_insertion_point(field_release:netcode.UserRegistrationRequest.email)
  
  return email_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserRegistrationRequest::set_allocated_email(::std::string* email) {
  if (email != NULL) {
    
  } else {
    
  }
  email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), email);
  // @@protoc_insertion_point(field_set_allocated:netcode.UserRegistrationRequest.email)
}

// string matr_number = 3;
inline void UserRegistrationRequest::clear_matr_number() {
  matr_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserRegistrationRequest::matr_number() const {
  // @@protoc_insertion_point(field_get:netcode.UserRegistrationRequest.matr_number)
  return matr_number_.GetNoArena();
}
inline void UserRegistrationRequest::set_matr_number(const ::std::string& value) {
  
  matr_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netcode.UserRegistrationRequest.matr_number)
}
#if LANG_CXX11
inline void UserRegistrationRequest::set_matr_number(::std::string&& value) {
  
  matr_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netcode.UserRegistrationRequest.matr_number)
}
#endif
inline void UserRegistrationRequest::set_matr_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  matr_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netcode.UserRegistrationRequest.matr_number)
}
inline void UserRegistrationRequest::set_matr_number(const char* value, size_t size) {
  
  matr_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netcode.UserRegistrationRequest.matr_number)
}
inline ::std::string* UserRegistrationRequest::mutable_matr_number() {
  
  // @@protoc_insertion_point(field_mutable:netcode.UserRegistrationRequest.matr_number)
  return matr_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserRegistrationRequest::release_matr_number() {
  // @@protoc_insertion_point(field_release:netcode.UserRegistrationRequest.matr_number)
  
  return matr_number_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserRegistrationRequest::set_allocated_matr_number(::std::string* matr_number) {
  if (matr_number != NULL) {
    
  } else {
    
  }
  matr_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), matr_number);
  // @@protoc_insertion_point(field_set_allocated:netcode.UserRegistrationRequest.matr_number)
}

// string secret = 4;
inline void UserRegistrationRequest::clear_secret() {
  secret_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserRegistrationRequest::secret() const {
  // @@protoc_insertion_point(field_get:netcode.UserRegistrationRequest.secret)
  return secret_.GetNoArena();
}
inline void UserRegistrationRequest::set_secret(const ::std::string& value) {
  
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netcode.UserRegistrationRequest.secret)
}
#if LANG_CXX11
inline void UserRegistrationRequest::set_secret(::std::string&& value) {
  
  secret_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netcode.UserRegistrationRequest.secret)
}
#endif
inline void UserRegistrationRequest::set_secret(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netcode.UserRegistrationRequest.secret)
}
inline void UserRegistrationRequest::set_secret(const char* value, size_t size) {
  
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netcode.UserRegistrationRequest.secret)
}
inline ::std::string* UserRegistrationRequest::mutable_secret() {
  
  // @@protoc_insertion_point(field_mutable:netcode.UserRegistrationRequest.secret)
  return secret_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserRegistrationRequest::release_secret() {
  // @@protoc_insertion_point(field_release:netcode.UserRegistrationRequest.secret)
  
  return secret_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserRegistrationRequest::set_allocated_secret(::std::string* secret) {
  if (secret != NULL) {
    
  } else {
    
  }
  secret_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), secret);
  // @@protoc_insertion_point(field_set_allocated:netcode.UserRegistrationRequest.secret)
}

// -------------------------------------------------------------------

// UserRegistrationResponse

// .netcode.UserRegistrationResponse.ErrorCode error_code = 1;
inline void UserRegistrationResponse::clear_error_code() {
  error_code_ = 0;
}
inline ::netcode::UserRegistrationResponse_ErrorCode UserRegistrationResponse::error_code() const {
  // @@protoc_insertion_point(field_get:netcode.UserRegistrationResponse.error_code)
  return static_cast< ::netcode::UserRegistrationResponse_ErrorCode >(error_code_);
}
inline void UserRegistrationResponse::set_error_code(::netcode::UserRegistrationResponse_ErrorCode value) {
  
  error_code_ = value;
  // @@protoc_insertion_point(field_set:netcode.UserRegistrationResponse.error_code)
}

// -------------------------------------------------------------------

// GroupRegistrationRequest

// .netcode.AuthPacket auth = 1;
inline bool GroupRegistrationRequest::has_auth() const {
  return this != internal_default_instance() && auth_ != NULL;
}
inline void GroupRegistrationRequest::clear_auth() {
  if (GetArenaNoVirtual() == NULL && auth_ != NULL) {
    delete auth_;
  }
  auth_ = NULL;
}
inline const ::netcode::AuthPacket& GroupRegistrationRequest::_internal_auth() const {
  return *auth_;
}
inline const ::netcode::AuthPacket& GroupRegistrationRequest::auth() const {
  const ::netcode::AuthPacket* p = auth_;
  // @@protoc_insertion_point(field_get:netcode.GroupRegistrationRequest.auth)
  return p != NULL ? *p : *reinterpret_cast<const ::netcode::AuthPacket*>(
      &::netcode::_AuthPacket_default_instance_);
}
inline ::netcode::AuthPacket* GroupRegistrationRequest::release_auth() {
  // @@protoc_insertion_point(field_release:netcode.GroupRegistrationRequest.auth)
  
  ::netcode::AuthPacket* temp = auth_;
  auth_ = NULL;
  return temp;
}
inline ::netcode::AuthPacket* GroupRegistrationRequest::mutable_auth() {
  
  if (auth_ == NULL) {
    auto* p = CreateMaybeMessage<::netcode::AuthPacket>(GetArenaNoVirtual());
    auth_ = p;
  }
  // @@protoc_insertion_point(field_mutable:netcode.GroupRegistrationRequest.auth)
  return auth_;
}
inline void GroupRegistrationRequest::set_allocated_auth(::netcode::AuthPacket* auth) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete auth_;
  }
  if (auth) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      auth = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, auth, submessage_arena);
    }
    
  } else {
    
  }
  auth_ = auth;
  // @@protoc_insertion_point(field_set_allocated:netcode.GroupRegistrationRequest.auth)
}

// repeated string matr_number = 2;
inline int GroupRegistrationRequest::matr_number_size() const {
  return matr_number_.size();
}
inline void GroupRegistrationRequest::clear_matr_number() {
  matr_number_.Clear();
}
inline const ::std::string& GroupRegistrationRequest::matr_number(int index) const {
  // @@protoc_insertion_point(field_get:netcode.GroupRegistrationRequest.matr_number)
  return matr_number_.Get(index);
}
inline ::std::string* GroupRegistrationRequest::mutable_matr_number(int index) {
  // @@protoc_insertion_point(field_mutable:netcode.GroupRegistrationRequest.matr_number)
  return matr_number_.Mutable(index);
}
inline void GroupRegistrationRequest::set_matr_number(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:netcode.GroupRegistrationRequest.matr_number)
  matr_number_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void GroupRegistrationRequest::set_matr_number(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:netcode.GroupRegistrationRequest.matr_number)
  matr_number_.Mutable(index)->assign(std::move(value));
}
#endif
inline void GroupRegistrationRequest::set_matr_number(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  matr_number_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:netcode.GroupRegistrationRequest.matr_number)
}
inline void GroupRegistrationRequest::set_matr_number(int index, const char* value, size_t size) {
  matr_number_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:netcode.GroupRegistrationRequest.matr_number)
}
inline ::std::string* GroupRegistrationRequest::add_matr_number() {
  // @@protoc_insertion_point(field_add_mutable:netcode.GroupRegistrationRequest.matr_number)
  return matr_number_.Add();
}
inline void GroupRegistrationRequest::add_matr_number(const ::std::string& value) {
  matr_number_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:netcode.GroupRegistrationRequest.matr_number)
}
#if LANG_CXX11
inline void GroupRegistrationRequest::add_matr_number(::std::string&& value) {
  matr_number_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:netcode.GroupRegistrationRequest.matr_number)
}
#endif
inline void GroupRegistrationRequest::add_matr_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  matr_number_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:netcode.GroupRegistrationRequest.matr_number)
}
inline void GroupRegistrationRequest::add_matr_number(const char* value, size_t size) {
  matr_number_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:netcode.GroupRegistrationRequest.matr_number)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GroupRegistrationRequest::matr_number() const {
  // @@protoc_insertion_point(field_list:netcode.GroupRegistrationRequest.matr_number)
  return matr_number_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GroupRegistrationRequest::mutable_matr_number() {
  // @@protoc_insertion_point(field_mutable_list:netcode.GroupRegistrationRequest.matr_number)
  return &matr_number_;
}

// -------------------------------------------------------------------

// GroupRegistrationResponse

// .netcode.GroupRegistrationResponse.ErrorCode error_code = 1;
inline void GroupRegistrationResponse::clear_error_code() {
  error_code_ = 0;
}
inline ::netcode::GroupRegistrationResponse_ErrorCode GroupRegistrationResponse::error_code() const {
  // @@protoc_insertion_point(field_get:netcode.GroupRegistrationResponse.error_code)
  return static_cast< ::netcode::GroupRegistrationResponse_ErrorCode >(error_code_);
}
inline void GroupRegistrationResponse::set_error_code(::netcode::GroupRegistrationResponse_ErrorCode value) {
  
  error_code_ = value;
  // @@protoc_insertion_point(field_set:netcode.GroupRegistrationResponse.error_code)
}

// -------------------------------------------------------------------

// DirectChallenge

// string user_pseudonym = 1;
inline void DirectChallenge::clear_user_pseudonym() {
  user_pseudonym_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DirectChallenge::user_pseudonym() const {
  // @@protoc_insertion_point(field_get:netcode.DirectChallenge.user_pseudonym)
  return user_pseudonym_.GetNoArena();
}
inline void DirectChallenge::set_user_pseudonym(const ::std::string& value) {
  
  user_pseudonym_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netcode.DirectChallenge.user_pseudonym)
}
#if LANG_CXX11
inline void DirectChallenge::set_user_pseudonym(::std::string&& value) {
  
  user_pseudonym_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netcode.DirectChallenge.user_pseudonym)
}
#endif
inline void DirectChallenge::set_user_pseudonym(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  user_pseudonym_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netcode.DirectChallenge.user_pseudonym)
}
inline void DirectChallenge::set_user_pseudonym(const char* value, size_t size) {
  
  user_pseudonym_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netcode.DirectChallenge.user_pseudonym)
}
inline ::std::string* DirectChallenge::mutable_user_pseudonym() {
  
  // @@protoc_insertion_point(field_mutable:netcode.DirectChallenge.user_pseudonym)
  return user_pseudonym_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DirectChallenge::release_user_pseudonym() {
  // @@protoc_insertion_point(field_release:netcode.DirectChallenge.user_pseudonym)
  
  return user_pseudonym_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DirectChallenge::set_allocated_user_pseudonym(::std::string* user_pseudonym) {
  if (user_pseudonym != NULL) {
    
  } else {
    
  }
  user_pseudonym_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_pseudonym);
  // @@protoc_insertion_point(field_set_allocated:netcode.DirectChallenge.user_pseudonym)
}

// -------------------------------------------------------------------

// MatchmakingParameter

// .netcode.Nothing random_is_default = 10;
inline bool MatchmakingParameter::has_random_is_default() const {
  return parameter_case() == kRandomIsDefault;
}
inline void MatchmakingParameter::set_has_random_is_default() {
  _oneof_case_[0] = kRandomIsDefault;
}
inline void MatchmakingParameter::clear_random_is_default() {
  if (has_random_is_default()) {
    delete parameter_.random_is_default_;
    clear_has_parameter();
  }
}
inline const ::netcode::Nothing& MatchmakingParameter::_internal_random_is_default() const {
  return *parameter_.random_is_default_;
}
inline ::netcode::Nothing* MatchmakingParameter::release_random_is_default() {
  // @@protoc_insertion_point(field_release:netcode.MatchmakingParameter.random_is_default)
  if (has_random_is_default()) {
    clear_has_parameter();
      ::netcode::Nothing* temp = parameter_.random_is_default_;
    parameter_.random_is_default_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::netcode::Nothing& MatchmakingParameter::random_is_default() const {
  // @@protoc_insertion_point(field_get:netcode.MatchmakingParameter.random_is_default)
  return has_random_is_default()
      ? *parameter_.random_is_default_
      : *reinterpret_cast< ::netcode::Nothing*>(&::netcode::_Nothing_default_instance_);
}
inline ::netcode::Nothing* MatchmakingParameter::mutable_random_is_default() {
  if (!has_random_is_default()) {
    clear_parameter();
    set_has_random_is_default();
    parameter_.random_is_default_ = CreateMaybeMessage< ::netcode::Nothing >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:netcode.MatchmakingParameter.random_is_default)
  return parameter_.random_is_default_;
}

// .netcode.DirectChallenge direct_matchmaking = 11;
inline bool MatchmakingParameter::has_direct_matchmaking() const {
  return parameter_case() == kDirectMatchmaking;
}
inline void MatchmakingParameter::set_has_direct_matchmaking() {
  _oneof_case_[0] = kDirectMatchmaking;
}
inline void MatchmakingParameter::clear_direct_matchmaking() {
  if (has_direct_matchmaking()) {
    delete parameter_.direct_matchmaking_;
    clear_has_parameter();
  }
}
inline const ::netcode::DirectChallenge& MatchmakingParameter::_internal_direct_matchmaking() const {
  return *parameter_.direct_matchmaking_;
}
inline ::netcode::DirectChallenge* MatchmakingParameter::release_direct_matchmaking() {
  // @@protoc_insertion_point(field_release:netcode.MatchmakingParameter.direct_matchmaking)
  if (has_direct_matchmaking()) {
    clear_has_parameter();
      ::netcode::DirectChallenge* temp = parameter_.direct_matchmaking_;
    parameter_.direct_matchmaking_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::netcode::DirectChallenge& MatchmakingParameter::direct_matchmaking() const {
  // @@protoc_insertion_point(field_get:netcode.MatchmakingParameter.direct_matchmaking)
  return has_direct_matchmaking()
      ? *parameter_.direct_matchmaking_
      : *reinterpret_cast< ::netcode::DirectChallenge*>(&::netcode::_DirectChallenge_default_instance_);
}
inline ::netcode::DirectChallenge* MatchmakingParameter::mutable_direct_matchmaking() {
  if (!has_direct_matchmaking()) {
    clear_parameter();
    set_has_direct_matchmaking();
    parameter_.direct_matchmaking_ = CreateMaybeMessage< ::netcode::DirectChallenge >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:netcode.MatchmakingParameter.direct_matchmaking)
  return parameter_.direct_matchmaking_;
}

inline bool MatchmakingParameter::has_parameter() const {
  return parameter_case() != PARAMETER_NOT_SET;
}
inline void MatchmakingParameter::clear_has_parameter() {
  _oneof_case_[0] = PARAMETER_NOT_SET;
}
inline MatchmakingParameter::ParameterCase MatchmakingParameter::parameter_case() const {
  return MatchmakingParameter::ParameterCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MatchRequest

// string user_token = 1;
inline void MatchRequest::clear_user_token() {
  user_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MatchRequest::user_token() const {
  // @@protoc_insertion_point(field_get:netcode.MatchRequest.user_token)
  return user_token_.GetNoArena();
}
inline void MatchRequest::set_user_token(const ::std::string& value) {
  
  user_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netcode.MatchRequest.user_token)
}
#if LANG_CXX11
inline void MatchRequest::set_user_token(::std::string&& value) {
  
  user_token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netcode.MatchRequest.user_token)
}
#endif
inline void MatchRequest::set_user_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  user_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netcode.MatchRequest.user_token)
}
inline void MatchRequest::set_user_token(const char* value, size_t size) {
  
  user_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netcode.MatchRequest.user_token)
}
inline ::std::string* MatchRequest::mutable_user_token() {
  
  // @@protoc_insertion_point(field_mutable:netcode.MatchRequest.user_token)
  return user_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MatchRequest::release_user_token() {
  // @@protoc_insertion_point(field_release:netcode.MatchRequest.user_token)
  
  return user_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MatchRequest::set_allocated_user_token(::std::string* user_token) {
  if (user_token != NULL) {
    
  } else {
    
  }
  user_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_token);
  // @@protoc_insertion_point(field_set_allocated:netcode.MatchRequest.user_token)
}

// string game_token = 2;
inline void MatchRequest::clear_game_token() {
  game_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MatchRequest::game_token() const {
  // @@protoc_insertion_point(field_get:netcode.MatchRequest.game_token)
  return game_token_.GetNoArena();
}
inline void MatchRequest::set_game_token(const ::std::string& value) {
  
  game_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netcode.MatchRequest.game_token)
}
#if LANG_CXX11
inline void MatchRequest::set_game_token(::std::string&& value) {
  
  game_token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netcode.MatchRequest.game_token)
}
#endif
inline void MatchRequest::set_game_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  game_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netcode.MatchRequest.game_token)
}
inline void MatchRequest::set_game_token(const char* value, size_t size) {
  
  game_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netcode.MatchRequest.game_token)
}
inline ::std::string* MatchRequest::mutable_game_token() {
  
  // @@protoc_insertion_point(field_mutable:netcode.MatchRequest.game_token)
  return game_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MatchRequest::release_game_token() {
  // @@protoc_insertion_point(field_release:netcode.MatchRequest.game_token)
  
  return game_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MatchRequest::set_allocated_game_token(::std::string* game_token) {
  if (game_token != NULL) {
    
  } else {
    
  }
  game_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), game_token);
  // @@protoc_insertion_point(field_set_allocated:netcode.MatchRequest.game_token)
}

// .netcode.MatchmakingParameter matchmaking_parameters = 3;
inline bool MatchRequest::has_matchmaking_parameters() const {
  return this != internal_default_instance() && matchmaking_parameters_ != NULL;
}
inline void MatchRequest::clear_matchmaking_parameters() {
  if (GetArenaNoVirtual() == NULL && matchmaking_parameters_ != NULL) {
    delete matchmaking_parameters_;
  }
  matchmaking_parameters_ = NULL;
}
inline const ::netcode::MatchmakingParameter& MatchRequest::_internal_matchmaking_parameters() const {
  return *matchmaking_parameters_;
}
inline const ::netcode::MatchmakingParameter& MatchRequest::matchmaking_parameters() const {
  const ::netcode::MatchmakingParameter* p = matchmaking_parameters_;
  // @@protoc_insertion_point(field_get:netcode.MatchRequest.matchmaking_parameters)
  return p != NULL ? *p : *reinterpret_cast<const ::netcode::MatchmakingParameter*>(
      &::netcode::_MatchmakingParameter_default_instance_);
}
inline ::netcode::MatchmakingParameter* MatchRequest::release_matchmaking_parameters() {
  // @@protoc_insertion_point(field_release:netcode.MatchRequest.matchmaking_parameters)
  
  ::netcode::MatchmakingParameter* temp = matchmaking_parameters_;
  matchmaking_parameters_ = NULL;
  return temp;
}
inline ::netcode::MatchmakingParameter* MatchRequest::mutable_matchmaking_parameters() {
  
  if (matchmaking_parameters_ == NULL) {
    auto* p = CreateMaybeMessage<::netcode::MatchmakingParameter>(GetArenaNoVirtual());
    matchmaking_parameters_ = p;
  }
  // @@protoc_insertion_point(field_mutable:netcode.MatchRequest.matchmaking_parameters)
  return matchmaking_parameters_;
}
inline void MatchRequest::set_allocated_matchmaking_parameters(::netcode::MatchmakingParameter* matchmaking_parameters) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete matchmaking_parameters_;
  }
  if (matchmaking_parameters) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      matchmaking_parameters = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, matchmaking_parameters, submessage_arena);
    }
    
  } else {
    
  }
  matchmaking_parameters_ = matchmaking_parameters;
  // @@protoc_insertion_point(field_set_allocated:netcode.MatchRequest.matchmaking_parameters)
}

// uint32 timeout_suggestion_seconds = 4;
inline void MatchRequest::clear_timeout_suggestion_seconds() {
  timeout_suggestion_seconds_ = 0u;
}
inline ::google::protobuf::uint32 MatchRequest::timeout_suggestion_seconds() const {
  // @@protoc_insertion_point(field_get:netcode.MatchRequest.timeout_suggestion_seconds)
  return timeout_suggestion_seconds_;
}
inline void MatchRequest::set_timeout_suggestion_seconds(::google::protobuf::uint32 value) {
  
  timeout_suggestion_seconds_ = value;
  // @@protoc_insertion_point(field_set:netcode.MatchRequest.timeout_suggestion_seconds)
}

// .nim.GameParameter nim_game_parameters = 10;
inline bool MatchRequest::has_nim_game_parameters() const {
  return game_parameters_case() == kNimGameParameters;
}
inline void MatchRequest::set_has_nim_game_parameters() {
  _oneof_case_[0] = kNimGameParameters;
}
inline const ::nim::GameParameter& MatchRequest::_internal_nim_game_parameters() const {
  return *game_parameters_.nim_game_parameters_;
}
inline ::nim::GameParameter* MatchRequest::release_nim_game_parameters() {
  // @@protoc_insertion_point(field_release:netcode.MatchRequest.nim_game_parameters)
  if (has_nim_game_parameters()) {
    clear_has_game_parameters();
      ::nim::GameParameter* temp = game_parameters_.nim_game_parameters_;
    game_parameters_.nim_game_parameters_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::nim::GameParameter& MatchRequest::nim_game_parameters() const {
  // @@protoc_insertion_point(field_get:netcode.MatchRequest.nim_game_parameters)
  return has_nim_game_parameters()
      ? *game_parameters_.nim_game_parameters_
      : *reinterpret_cast< ::nim::GameParameter*>(&::nim::_GameParameter_default_instance_);
}
inline ::nim::GameParameter* MatchRequest::mutable_nim_game_parameters() {
  if (!has_nim_game_parameters()) {
    clear_game_parameters();
    set_has_nim_game_parameters();
    game_parameters_.nim_game_parameters_ = CreateMaybeMessage< ::nim::GameParameter >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:netcode.MatchRequest.nim_game_parameters)
  return game_parameters_.nim_game_parameters_;
}

// .dab.GameParameter dab_game_parameters = 11;
inline bool MatchRequest::has_dab_game_parameters() const {
  return game_parameters_case() == kDabGameParameters;
}
inline void MatchRequest::set_has_dab_game_parameters() {
  _oneof_case_[0] = kDabGameParameters;
}
inline const ::dab::GameParameter& MatchRequest::_internal_dab_game_parameters() const {
  return *game_parameters_.dab_game_parameters_;
}
inline ::dab::GameParameter* MatchRequest::release_dab_game_parameters() {
  // @@protoc_insertion_point(field_release:netcode.MatchRequest.dab_game_parameters)
  if (has_dab_game_parameters()) {
    clear_has_game_parameters();
      ::dab::GameParameter* temp = game_parameters_.dab_game_parameters_;
    game_parameters_.dab_game_parameters_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dab::GameParameter& MatchRequest::dab_game_parameters() const {
  // @@protoc_insertion_point(field_get:netcode.MatchRequest.dab_game_parameters)
  return has_dab_game_parameters()
      ? *game_parameters_.dab_game_parameters_
      : *reinterpret_cast< ::dab::GameParameter*>(&::dab::_GameParameter_default_instance_);
}
inline ::dab::GameParameter* MatchRequest::mutable_dab_game_parameters() {
  if (!has_dab_game_parameters()) {
    clear_game_parameters();
    set_has_dab_game_parameters();
    game_parameters_.dab_game_parameters_ = CreateMaybeMessage< ::dab::GameParameter >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:netcode.MatchRequest.dab_game_parameters)
  return game_parameters_.dab_game_parameters_;
}

// .dom.GameParameter dom_game_parameters = 12;
inline bool MatchRequest::has_dom_game_parameters() const {
  return game_parameters_case() == kDomGameParameters;
}
inline void MatchRequest::set_has_dom_game_parameters() {
  _oneof_case_[0] = kDomGameParameters;
}
inline const ::dom::GameParameter& MatchRequest::_internal_dom_game_parameters() const {
  return *game_parameters_.dom_game_parameters_;
}
inline ::dom::GameParameter* MatchRequest::release_dom_game_parameters() {
  // @@protoc_insertion_point(field_release:netcode.MatchRequest.dom_game_parameters)
  if (has_dom_game_parameters()) {
    clear_has_game_parameters();
      ::dom::GameParameter* temp = game_parameters_.dom_game_parameters_;
    game_parameters_.dom_game_parameters_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dom::GameParameter& MatchRequest::dom_game_parameters() const {
  // @@protoc_insertion_point(field_get:netcode.MatchRequest.dom_game_parameters)
  return has_dom_game_parameters()
      ? *game_parameters_.dom_game_parameters_
      : *reinterpret_cast< ::dom::GameParameter*>(&::dom::_GameParameter_default_instance_);
}
inline ::dom::GameParameter* MatchRequest::mutable_dom_game_parameters() {
  if (!has_dom_game_parameters()) {
    clear_game_parameters();
    set_has_dom_game_parameters();
    game_parameters_.dom_game_parameters_ = CreateMaybeMessage< ::dom::GameParameter >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:netcode.MatchRequest.dom_game_parameters)
  return game_parameters_.dom_game_parameters_;
}

inline bool MatchRequest::has_game_parameters() const {
  return game_parameters_case() != GAME_PARAMETERS_NOT_SET;
}
inline void MatchRequest::clear_has_game_parameters() {
  _oneof_case_[0] = GAME_PARAMETERS_NOT_SET;
}
inline MatchRequest::GameParametersCase MatchRequest::game_parameters_case() const {
  return MatchRequest::GameParametersCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MatchResponse

// string match_token = 1;
inline void MatchResponse::clear_match_token() {
  match_token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MatchResponse::match_token() const {
  // @@protoc_insertion_point(field_get:netcode.MatchResponse.match_token)
  return match_token_.GetNoArena();
}
inline void MatchResponse::set_match_token(const ::std::string& value) {
  
  match_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netcode.MatchResponse.match_token)
}
#if LANG_CXX11
inline void MatchResponse::set_match_token(::std::string&& value) {
  
  match_token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netcode.MatchResponse.match_token)
}
#endif
inline void MatchResponse::set_match_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  match_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netcode.MatchResponse.match_token)
}
inline void MatchResponse::set_match_token(const char* value, size_t size) {
  
  match_token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netcode.MatchResponse.match_token)
}
inline ::std::string* MatchResponse::mutable_match_token() {
  
  // @@protoc_insertion_point(field_mutable:netcode.MatchResponse.match_token)
  return match_token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MatchResponse::release_match_token() {
  // @@protoc_insertion_point(field_release:netcode.MatchResponse.match_token)
  
  return match_token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MatchResponse::set_allocated_match_token(::std::string* match_token) {
  if (match_token != NULL) {
    
  } else {
    
  }
  match_token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), match_token);
  // @@protoc_insertion_point(field_set_allocated:netcode.MatchResponse.match_token)
}

// bool beginning_player = 2;
inline void MatchResponse::clear_beginning_player() {
  beginning_player_ = false;
}
inline bool MatchResponse::beginning_player() const {
  // @@protoc_insertion_point(field_get:netcode.MatchResponse.beginning_player)
  return beginning_player_;
}
inline void MatchResponse::set_beginning_player(bool value) {
  
  beginning_player_ = value;
  // @@protoc_insertion_point(field_set:netcode.MatchResponse.beginning_player)
}

// -------------------------------------------------------------------

// TurnRequest

// .netcode.MatchIDPacket match_id = 1;
inline bool TurnRequest::has_match_id() const {
  return this != internal_default_instance() && match_id_ != NULL;
}
inline void TurnRequest::clear_match_id() {
  if (GetArenaNoVirtual() == NULL && match_id_ != NULL) {
    delete match_id_;
  }
  match_id_ = NULL;
}
inline const ::netcode::MatchIDPacket& TurnRequest::_internal_match_id() const {
  return *match_id_;
}
inline const ::netcode::MatchIDPacket& TurnRequest::match_id() const {
  const ::netcode::MatchIDPacket* p = match_id_;
  // @@protoc_insertion_point(field_get:netcode.TurnRequest.match_id)
  return p != NULL ? *p : *reinterpret_cast<const ::netcode::MatchIDPacket*>(
      &::netcode::_MatchIDPacket_default_instance_);
}
inline ::netcode::MatchIDPacket* TurnRequest::release_match_id() {
  // @@protoc_insertion_point(field_release:netcode.TurnRequest.match_id)
  
  ::netcode::MatchIDPacket* temp = match_id_;
  match_id_ = NULL;
  return temp;
}
inline ::netcode::MatchIDPacket* TurnRequest::mutable_match_id() {
  
  if (match_id_ == NULL) {
    auto* p = CreateMaybeMessage<::netcode::MatchIDPacket>(GetArenaNoVirtual());
    match_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:netcode.TurnRequest.match_id)
  return match_id_;
}
inline void TurnRequest::set_allocated_match_id(::netcode::MatchIDPacket* match_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete match_id_;
  }
  if (match_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      match_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, match_id, submessage_arena);
    }
    
  } else {
    
  }
  match_id_ = match_id;
  // @@protoc_insertion_point(field_set_allocated:netcode.TurnRequest.match_id)
}

// .nim.GameTurn nim_game_turn = 10;
inline bool TurnRequest::has_nim_game_turn() const {
  return game_turn_case() == kNimGameTurn;
}
inline void TurnRequest::set_has_nim_game_turn() {
  _oneof_case_[0] = kNimGameTurn;
}
inline const ::nim::GameTurn& TurnRequest::_internal_nim_game_turn() const {
  return *game_turn_.nim_game_turn_;
}
inline ::nim::GameTurn* TurnRequest::release_nim_game_turn() {
  // @@protoc_insertion_point(field_release:netcode.TurnRequest.nim_game_turn)
  if (has_nim_game_turn()) {
    clear_has_game_turn();
      ::nim::GameTurn* temp = game_turn_.nim_game_turn_;
    game_turn_.nim_game_turn_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::nim::GameTurn& TurnRequest::nim_game_turn() const {
  // @@protoc_insertion_point(field_get:netcode.TurnRequest.nim_game_turn)
  return has_nim_game_turn()
      ? *game_turn_.nim_game_turn_
      : *reinterpret_cast< ::nim::GameTurn*>(&::nim::_GameTurn_default_instance_);
}
inline ::nim::GameTurn* TurnRequest::mutable_nim_game_turn() {
  if (!has_nim_game_turn()) {
    clear_game_turn();
    set_has_nim_game_turn();
    game_turn_.nim_game_turn_ = CreateMaybeMessage< ::nim::GameTurn >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:netcode.TurnRequest.nim_game_turn)
  return game_turn_.nim_game_turn_;
}

// .dab.GameTurn dab_game_turn = 11;
inline bool TurnRequest::has_dab_game_turn() const {
  return game_turn_case() == kDabGameTurn;
}
inline void TurnRequest::set_has_dab_game_turn() {
  _oneof_case_[0] = kDabGameTurn;
}
inline const ::dab::GameTurn& TurnRequest::_internal_dab_game_turn() const {
  return *game_turn_.dab_game_turn_;
}
inline ::dab::GameTurn* TurnRequest::release_dab_game_turn() {
  // @@protoc_insertion_point(field_release:netcode.TurnRequest.dab_game_turn)
  if (has_dab_game_turn()) {
    clear_has_game_turn();
      ::dab::GameTurn* temp = game_turn_.dab_game_turn_;
    game_turn_.dab_game_turn_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dab::GameTurn& TurnRequest::dab_game_turn() const {
  // @@protoc_insertion_point(field_get:netcode.TurnRequest.dab_game_turn)
  return has_dab_game_turn()
      ? *game_turn_.dab_game_turn_
      : *reinterpret_cast< ::dab::GameTurn*>(&::dab::_GameTurn_default_instance_);
}
inline ::dab::GameTurn* TurnRequest::mutable_dab_game_turn() {
  if (!has_dab_game_turn()) {
    clear_game_turn();
    set_has_dab_game_turn();
    game_turn_.dab_game_turn_ = CreateMaybeMessage< ::dab::GameTurn >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:netcode.TurnRequest.dab_game_turn)
  return game_turn_.dab_game_turn_;
}

// .dom.GameTurn dom_game_turn = 12;
inline bool TurnRequest::has_dom_game_turn() const {
  return game_turn_case() == kDomGameTurn;
}
inline void TurnRequest::set_has_dom_game_turn() {
  _oneof_case_[0] = kDomGameTurn;
}
inline const ::dom::GameTurn& TurnRequest::_internal_dom_game_turn() const {
  return *game_turn_.dom_game_turn_;
}
inline ::dom::GameTurn* TurnRequest::release_dom_game_turn() {
  // @@protoc_insertion_point(field_release:netcode.TurnRequest.dom_game_turn)
  if (has_dom_game_turn()) {
    clear_has_game_turn();
      ::dom::GameTurn* temp = game_turn_.dom_game_turn_;
    game_turn_.dom_game_turn_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dom::GameTurn& TurnRequest::dom_game_turn() const {
  // @@protoc_insertion_point(field_get:netcode.TurnRequest.dom_game_turn)
  return has_dom_game_turn()
      ? *game_turn_.dom_game_turn_
      : *reinterpret_cast< ::dom::GameTurn*>(&::dom::_GameTurn_default_instance_);
}
inline ::dom::GameTurn* TurnRequest::mutable_dom_game_turn() {
  if (!has_dom_game_turn()) {
    clear_game_turn();
    set_has_dom_game_turn();
    game_turn_.dom_game_turn_ = CreateMaybeMessage< ::dom::GameTurn >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:netcode.TurnRequest.dom_game_turn)
  return game_turn_.dom_game_turn_;
}

inline bool TurnRequest::has_game_turn() const {
  return game_turn_case() != GAME_TURN_NOT_SET;
}
inline void TurnRequest::clear_has_game_turn() {
  _oneof_case_[0] = GAME_TURN_NOT_SET;
}
inline TurnRequest::GameTurnCase TurnRequest::game_turn_case() const {
  return TurnRequest::GameTurnCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// TurnResponse

// .netcode.TurnStatus turn_status = 1;
inline void TurnResponse::clear_turn_status() {
  turn_status_ = 0;
}
inline ::netcode::TurnStatus TurnResponse::turn_status() const {
  // @@protoc_insertion_point(field_get:netcode.TurnResponse.turn_status)
  return static_cast< ::netcode::TurnStatus >(turn_status_);
}
inline void TurnResponse::set_turn_status(::netcode::TurnStatus value) {
  
  turn_status_ = value;
  // @@protoc_insertion_point(field_set:netcode.TurnResponse.turn_status)
}

// .nim.GameState nim_game_state = 10;
inline bool TurnResponse::has_nim_game_state() const {
  return game_state_case() == kNimGameState;
}
inline void TurnResponse::set_has_nim_game_state() {
  _oneof_case_[0] = kNimGameState;
}
inline const ::nim::GameState& TurnResponse::_internal_nim_game_state() const {
  return *game_state_.nim_game_state_;
}
inline ::nim::GameState* TurnResponse::release_nim_game_state() {
  // @@protoc_insertion_point(field_release:netcode.TurnResponse.nim_game_state)
  if (has_nim_game_state()) {
    clear_has_game_state();
      ::nim::GameState* temp = game_state_.nim_game_state_;
    game_state_.nim_game_state_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::nim::GameState& TurnResponse::nim_game_state() const {
  // @@protoc_insertion_point(field_get:netcode.TurnResponse.nim_game_state)
  return has_nim_game_state()
      ? *game_state_.nim_game_state_
      : *reinterpret_cast< ::nim::GameState*>(&::nim::_GameState_default_instance_);
}
inline ::nim::GameState* TurnResponse::mutable_nim_game_state() {
  if (!has_nim_game_state()) {
    clear_game_state();
    set_has_nim_game_state();
    game_state_.nim_game_state_ = CreateMaybeMessage< ::nim::GameState >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:netcode.TurnResponse.nim_game_state)
  return game_state_.nim_game_state_;
}

// .dab.GameState dab_game_state = 11;
inline bool TurnResponse::has_dab_game_state() const {
  return game_state_case() == kDabGameState;
}
inline void TurnResponse::set_has_dab_game_state() {
  _oneof_case_[0] = kDabGameState;
}
inline const ::dab::GameState& TurnResponse::_internal_dab_game_state() const {
  return *game_state_.dab_game_state_;
}
inline ::dab::GameState* TurnResponse::release_dab_game_state() {
  // @@protoc_insertion_point(field_release:netcode.TurnResponse.dab_game_state)
  if (has_dab_game_state()) {
    clear_has_game_state();
      ::dab::GameState* temp = game_state_.dab_game_state_;
    game_state_.dab_game_state_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dab::GameState& TurnResponse::dab_game_state() const {
  // @@protoc_insertion_point(field_get:netcode.TurnResponse.dab_game_state)
  return has_dab_game_state()
      ? *game_state_.dab_game_state_
      : *reinterpret_cast< ::dab::GameState*>(&::dab::_GameState_default_instance_);
}
inline ::dab::GameState* TurnResponse::mutable_dab_game_state() {
  if (!has_dab_game_state()) {
    clear_game_state();
    set_has_dab_game_state();
    game_state_.dab_game_state_ = CreateMaybeMessage< ::dab::GameState >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:netcode.TurnResponse.dab_game_state)
  return game_state_.dab_game_state_;
}

// .dom.GameState dom_game_state = 12;
inline bool TurnResponse::has_dom_game_state() const {
  return game_state_case() == kDomGameState;
}
inline void TurnResponse::set_has_dom_game_state() {
  _oneof_case_[0] = kDomGameState;
}
inline const ::dom::GameState& TurnResponse::_internal_dom_game_state() const {
  return *game_state_.dom_game_state_;
}
inline ::dom::GameState* TurnResponse::release_dom_game_state() {
  // @@protoc_insertion_point(field_release:netcode.TurnResponse.dom_game_state)
  if (has_dom_game_state()) {
    clear_has_game_state();
      ::dom::GameState* temp = game_state_.dom_game_state_;
    game_state_.dom_game_state_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dom::GameState& TurnResponse::dom_game_state() const {
  // @@protoc_insertion_point(field_get:netcode.TurnResponse.dom_game_state)
  return has_dom_game_state()
      ? *game_state_.dom_game_state_
      : *reinterpret_cast< ::dom::GameState*>(&::dom::_GameState_default_instance_);
}
inline ::dom::GameState* TurnResponse::mutable_dom_game_state() {
  if (!has_dom_game_state()) {
    clear_game_state();
    set_has_dom_game_state();
    game_state_.dom_game_state_ = CreateMaybeMessage< ::dom::GameState >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:netcode.TurnResponse.dom_game_state)
  return game_state_.dom_game_state_;
}

inline bool TurnResponse::has_game_state() const {
  return game_state_case() != GAME_STATE_NOT_SET;
}
inline void TurnResponse::clear_has_game_state() {
  _oneof_case_[0] = GAME_STATE_NOT_SET;
}
inline TurnResponse::GameStateCase TurnResponse::game_state_case() const {
  return TurnResponse::GameStateCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GameStateResponse

// .netcode.GameStatus game_status = 1;
inline void GameStateResponse::clear_game_status() {
  game_status_ = 0;
}
inline ::netcode::GameStatus GameStateResponse::game_status() const {
  // @@protoc_insertion_point(field_get:netcode.GameStateResponse.game_status)
  return static_cast< ::netcode::GameStatus >(game_status_);
}
inline void GameStateResponse::set_game_status(::netcode::GameStatus value) {
  
  game_status_ = value;
  // @@protoc_insertion_point(field_set:netcode.GameStateResponse.game_status)
}

// bool beginning_player = 2;
inline void GameStateResponse::clear_beginning_player() {
  beginning_player_ = false;
}
inline bool GameStateResponse::beginning_player() const {
  // @@protoc_insertion_point(field_get:netcode.GameStateResponse.beginning_player)
  return beginning_player_;
}
inline void GameStateResponse::set_beginning_player(bool value) {
  
  beginning_player_ = value;
  // @@protoc_insertion_point(field_set:netcode.GameStateResponse.beginning_player)
}

// .nim.GameState nim_game_state = 10;
inline bool GameStateResponse::has_nim_game_state() const {
  return game_state_case() == kNimGameState;
}
inline void GameStateResponse::set_has_nim_game_state() {
  _oneof_case_[0] = kNimGameState;
}
inline const ::nim::GameState& GameStateResponse::_internal_nim_game_state() const {
  return *game_state_.nim_game_state_;
}
inline ::nim::GameState* GameStateResponse::release_nim_game_state() {
  // @@protoc_insertion_point(field_release:netcode.GameStateResponse.nim_game_state)
  if (has_nim_game_state()) {
    clear_has_game_state();
      ::nim::GameState* temp = game_state_.nim_game_state_;
    game_state_.nim_game_state_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::nim::GameState& GameStateResponse::nim_game_state() const {
  // @@protoc_insertion_point(field_get:netcode.GameStateResponse.nim_game_state)
  return has_nim_game_state()
      ? *game_state_.nim_game_state_
      : *reinterpret_cast< ::nim::GameState*>(&::nim::_GameState_default_instance_);
}
inline ::nim::GameState* GameStateResponse::mutable_nim_game_state() {
  if (!has_nim_game_state()) {
    clear_game_state();
    set_has_nim_game_state();
    game_state_.nim_game_state_ = CreateMaybeMessage< ::nim::GameState >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:netcode.GameStateResponse.nim_game_state)
  return game_state_.nim_game_state_;
}

// .dab.GameState dab_game_state = 11;
inline bool GameStateResponse::has_dab_game_state() const {
  return game_state_case() == kDabGameState;
}
inline void GameStateResponse::set_has_dab_game_state() {
  _oneof_case_[0] = kDabGameState;
}
inline const ::dab::GameState& GameStateResponse::_internal_dab_game_state() const {
  return *game_state_.dab_game_state_;
}
inline ::dab::GameState* GameStateResponse::release_dab_game_state() {
  // @@protoc_insertion_point(field_release:netcode.GameStateResponse.dab_game_state)
  if (has_dab_game_state()) {
    clear_has_game_state();
      ::dab::GameState* temp = game_state_.dab_game_state_;
    game_state_.dab_game_state_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dab::GameState& GameStateResponse::dab_game_state() const {
  // @@protoc_insertion_point(field_get:netcode.GameStateResponse.dab_game_state)
  return has_dab_game_state()
      ? *game_state_.dab_game_state_
      : *reinterpret_cast< ::dab::GameState*>(&::dab::_GameState_default_instance_);
}
inline ::dab::GameState* GameStateResponse::mutable_dab_game_state() {
  if (!has_dab_game_state()) {
    clear_game_state();
    set_has_dab_game_state();
    game_state_.dab_game_state_ = CreateMaybeMessage< ::dab::GameState >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:netcode.GameStateResponse.dab_game_state)
  return game_state_.dab_game_state_;
}

// .dom.GameState dom_game_state = 12;
inline bool GameStateResponse::has_dom_game_state() const {
  return game_state_case() == kDomGameState;
}
inline void GameStateResponse::set_has_dom_game_state() {
  _oneof_case_[0] = kDomGameState;
}
inline const ::dom::GameState& GameStateResponse::_internal_dom_game_state() const {
  return *game_state_.dom_game_state_;
}
inline ::dom::GameState* GameStateResponse::release_dom_game_state() {
  // @@protoc_insertion_point(field_release:netcode.GameStateResponse.dom_game_state)
  if (has_dom_game_state()) {
    clear_has_game_state();
      ::dom::GameState* temp = game_state_.dom_game_state_;
    game_state_.dom_game_state_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::dom::GameState& GameStateResponse::dom_game_state() const {
  // @@protoc_insertion_point(field_get:netcode.GameStateResponse.dom_game_state)
  return has_dom_game_state()
      ? *game_state_.dom_game_state_
      : *reinterpret_cast< ::dom::GameState*>(&::dom::_GameState_default_instance_);
}
inline ::dom::GameState* GameStateResponse::mutable_dom_game_state() {
  if (!has_dom_game_state()) {
    clear_game_state();
    set_has_dom_game_state();
    game_state_.dom_game_state_ = CreateMaybeMessage< ::dom::GameState >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:netcode.GameStateResponse.dom_game_state)
  return game_state_.dom_game_state_;
}

inline bool GameStateResponse::has_game_state() const {
  return game_state_case() != GAME_STATE_NOT_SET;
}
inline void GameStateResponse::clear_has_game_state() {
  _oneof_case_[0] = GAME_STATE_NOT_SET;
}
inline GameStateResponse::GameStateCase GameStateResponse::game_state_case() const {
  return GameStateResponse::GameStateCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// OpponentInfoResponse

// string user_pseudonym = 1;
inline void OpponentInfoResponse::clear_user_pseudonym() {
  user_pseudonym_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OpponentInfoResponse::user_pseudonym() const {
  // @@protoc_insertion_point(field_get:netcode.OpponentInfoResponse.user_pseudonym)
  return user_pseudonym_.GetNoArena();
}
inline void OpponentInfoResponse::set_user_pseudonym(const ::std::string& value) {
  
  user_pseudonym_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netcode.OpponentInfoResponse.user_pseudonym)
}
#if LANG_CXX11
inline void OpponentInfoResponse::set_user_pseudonym(::std::string&& value) {
  
  user_pseudonym_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netcode.OpponentInfoResponse.user_pseudonym)
}
#endif
inline void OpponentInfoResponse::set_user_pseudonym(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  user_pseudonym_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netcode.OpponentInfoResponse.user_pseudonym)
}
inline void OpponentInfoResponse::set_user_pseudonym(const char* value, size_t size) {
  
  user_pseudonym_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netcode.OpponentInfoResponse.user_pseudonym)
}
inline ::std::string* OpponentInfoResponse::mutable_user_pseudonym() {
  
  // @@protoc_insertion_point(field_mutable:netcode.OpponentInfoResponse.user_pseudonym)
  return user_pseudonym_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpponentInfoResponse::release_user_pseudonym() {
  // @@protoc_insertion_point(field_release:netcode.OpponentInfoResponse.user_pseudonym)
  
  return user_pseudonym_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpponentInfoResponse::set_allocated_user_pseudonym(::std::string* user_pseudonym) {
  if (user_pseudonym != NULL) {
    
  } else {
    
  }
  user_pseudonym_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_pseudonym);
  // @@protoc_insertion_point(field_set_allocated:netcode.OpponentInfoResponse.user_pseudonym)
}

// string group_pseudonym = 2;
inline void OpponentInfoResponse::clear_group_pseudonym() {
  group_pseudonym_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OpponentInfoResponse::group_pseudonym() const {
  // @@protoc_insertion_point(field_get:netcode.OpponentInfoResponse.group_pseudonym)
  return group_pseudonym_.GetNoArena();
}
inline void OpponentInfoResponse::set_group_pseudonym(const ::std::string& value) {
  
  group_pseudonym_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:netcode.OpponentInfoResponse.group_pseudonym)
}
#if LANG_CXX11
inline void OpponentInfoResponse::set_group_pseudonym(::std::string&& value) {
  
  group_pseudonym_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:netcode.OpponentInfoResponse.group_pseudonym)
}
#endif
inline void OpponentInfoResponse::set_group_pseudonym(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  group_pseudonym_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:netcode.OpponentInfoResponse.group_pseudonym)
}
inline void OpponentInfoResponse::set_group_pseudonym(const char* value, size_t size) {
  
  group_pseudonym_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:netcode.OpponentInfoResponse.group_pseudonym)
}
inline ::std::string* OpponentInfoResponse::mutable_group_pseudonym() {
  
  // @@protoc_insertion_point(field_mutable:netcode.OpponentInfoResponse.group_pseudonym)
  return group_pseudonym_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OpponentInfoResponse::release_group_pseudonym() {
  // @@protoc_insertion_point(field_release:netcode.OpponentInfoResponse.group_pseudonym)
  
  return group_pseudonym_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OpponentInfoResponse::set_allocated_group_pseudonym(::std::string* group_pseudonym) {
  if (group_pseudonym != NULL) {
    
  } else {
    
  }
  group_pseudonym_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), group_pseudonym);
  // @@protoc_insertion_point(field_set_allocated:netcode.OpponentInfoResponse.group_pseudonym)
}

// -------------------------------------------------------------------

// Nothing

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace netcode

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::netcode::SetPseudonymResponse_ErrorCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::netcode::SetPseudonymResponse_ErrorCode>() {
  return ::netcode::SetPseudonymResponse_ErrorCode_descriptor();
}
template <> struct is_proto_enum< ::netcode::UserRegistrationResponse_ErrorCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::netcode::UserRegistrationResponse_ErrorCode>() {
  return ::netcode::UserRegistrationResponse_ErrorCode_descriptor();
}
template <> struct is_proto_enum< ::netcode::GroupRegistrationResponse_ErrorCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::netcode::GroupRegistrationResponse_ErrorCode>() {
  return ::netcode::GroupRegistrationResponse_ErrorCode_descriptor();
}
template <> struct is_proto_enum< ::netcode::TurnStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::netcode::TurnStatus>() {
  return ::netcode::TurnStatus_descriptor();
}
template <> struct is_proto_enum< ::netcode::GameStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::netcode::GameStatus>() {
  return ::netcode::GameStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_netcode_2eproto
